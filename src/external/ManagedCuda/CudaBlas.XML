<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CudaBlas</name>
    </assembly>
    <members>
        <member name="T:ManagedCuda.CudaBlas.CudaBlasNativeMethods">
            <summary>
            C# wrapper for cublas_v2.h and cublas_api.h
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCreate_v2(ManagedCuda.CudaBlas.CudaBlasHandle@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDestroy_v2(ManagedCuda.CudaBlas.CudaBlasHandle)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetVersion_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetWorkspace_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.SizeT)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetStream_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetStream_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUstream@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetPointerMode_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.PointerMode@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetPointerMode_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.PointerMode)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetAtomicsMode(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.AtomicsMode@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetAtomicsMode(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.AtomicsMode)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetMathMode(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Math@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetMathMode(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Math)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetSmCountTarget(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetSmCountTarget(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetVector(System.Int32,System.Int32,System.IntPtr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            copies n elements from a vector x in CPU memory space to a vector y 
            in GPU memory space. Elements in both vectors are assumed to have a 
            size of elemSize bytes. Storage spacing between consecutive elements
            is incx for the source vector x and incy for the destination vector
            y. In general, y points to an object, or part of an object, allocated
            via cublasAlloc(). Column major format for two-dimensional matrices
            is assumed throughout CUBLAS. Therefore, if the increment for a vector 
            is equal to 1, this access a column vector while using an increment 
            equal to the leading dimension of the respective matrix accesses a 
            row vector.
            </summary>
            <returns>
            CudaBlas Error Codes: <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue"/>,
            <see cref="F:ManagedCuda.CudaBlas.CublasStatus.MappingError"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized"/>.
            </returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetVector(System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            copies n elements from a vector x in GPU memory space to a vector y 
            in CPU memory space. Elements in both vectors are assumed to have a 
            size of elemSize bytes. Storage spacing between consecutive elements
            is incx for the source vector x and incy for the destination vector
            y. In general, x points to an object, or part of an object, allocated
            via cublasAlloc(). Column major format for two-dimensional matrices
            is assumed throughout CUBLAS. Therefore, if the increment for a vector 
            is equal to 1, this access a column vector while using an increment 
            equal to the leading dimension of the respective matrix accesses a 
            row vector.
            </summary>
            <returns>
            CudaBlas Error Codes: <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue"/>,
            <see cref="F:ManagedCuda.CudaBlas.CublasStatus.MappingError"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized"/>.
            </returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetMatrix(System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            copies a tile of rows x cols elements from a matrix A in CPU memory
            space to a matrix B in GPU memory space. Each element requires storage
            of elemSize bytes. Both matrices are assumed to be stored in column 
            major format, with the leading dimension (i.e. number of rows) of 
            source matrix A provided in lda, and the leading dimension of matrix B
            provided in ldb. In general, B points to an object, or part of an 
            object, that was allocated via cublasAlloc().
            </summary>
            <returns>
            CudaBlas Error Codes: <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue"/>,
            <see cref="F:ManagedCuda.CudaBlas.CublasStatus.MappingError"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized"/>.
            </returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetMatrix(System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            copies a tile of rows x cols elements from a matrix A in GPU memory
            space to a matrix B in CPU memory space. Each element requires storage
            of elemSize bytes. Both matrices are assumed to be stored in column 
            major format, with the leading dimension (i.e. number of rows) of 
            source matrix A provided in lda, and the leading dimension of matrix B
            provided in ldb. In general, A points to an object, or part of an 
            object, that was allocated via cublasAlloc().
            </summary>
            <returns>
            CudaBlas Error Codes: <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue"/>,
            <see cref="F:ManagedCuda.CudaBlas.CublasStatus.MappingError"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized"/>.
            </returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetVectorAsync(System.Int32,System.Int32,System.IntPtr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            cublasSetVectorAsync has the same functionnality as cublasSetVector
            but the transfer is done asynchronously within the CUDA stream passed
            in parameter.
            </summary>
            <returns>
            CudaBlas Error Codes: <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue"/>,
            <see cref="F:ManagedCuda.CudaBlas.CublasStatus.MappingError"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized"/>.
            </returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetVectorAsync(System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.IntPtr,System.Int32,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            cublasGetVectorAsync has the same functionnality as cublasGetVector
            but the transfer is done asynchronously within the CUDA stream passed
            in parameter.
            </summary>
            <returns>
            CudaBlas Error Codes: <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue"/>,
            <see cref="F:ManagedCuda.CudaBlas.CublasStatus.MappingError"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized"/>.
            </returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetMatrixAsync(System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            cublasSetMatrixAsync has the same functionnality as cublasSetMatrix
            but the transfer is done asynchronously within the CUDA stream passed
            in parameter.
            </summary>
            <returns>
            CudaBlas Error Codes: <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue"/>,
            <see cref="F:ManagedCuda.CudaBlas.CublasStatus.MappingError"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized"/>.
            </returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetMatrixAsync(System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.IntPtr,System.Int32,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            cublasGetMatrixAsync has the same functionnality as cublasGetMatrix
            but the transfer is done asynchronously within the CUDA stream passed
            in parameter.
            </summary>
            <returns>
            CudaBlas Error Codes: <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue"/>,
            <see cref="F:ManagedCuda.CudaBlas.CublasStatus.MappingError"/>, <see cref="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized"/>.
            </returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCopyEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasScopy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDcopy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCcopy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZcopy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSswap_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDswap_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCswap_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZswap_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSwapEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasNrm2Ex(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDotEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDotcEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSnrm2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDnrm2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasScnrm2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDznrm2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSdot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDdot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCdotu_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCdotc_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdotu_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdotc_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasScalEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasAxpyEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSaxpy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDaxpy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCaxpy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZaxpy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIsamax_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIdamax_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIcamax_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIzamax_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIamaxEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIsamin_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIdamin_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIcamin_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIzamin_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIaminEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int32@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasAsumEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSasum_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDasum_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasScasum_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDzasum_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,System.Double@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,System.Double@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasRotEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSrotg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDrotg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCrotg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.VectorTypes.cuFloatComplex@,System.Single@,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZrotg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.VectorTypes.cuDoubleComplex@,System.Double@,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasRotgEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.IntPtr,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,System.IntPtr,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSrotm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single[])">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDrotm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double[])">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasRotmEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSrotmg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Single@,System.Single@,System.Single@,System.Single@,System.Single[])">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDrotmg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Double@,System.Double@,System.Double@,System.Double@,System.Double[])">
            <summary>
            </summary> 
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasRotmgEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary> 
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasNrm2Ex(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDotEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDotcEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSnrm2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDnrm2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasScnrm2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDznrm2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSdot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDdot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCdotu_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCdotc_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdotu_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdotc_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasScalEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdscal_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasAxpyEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSaxpy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDaxpy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCaxpy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZaxpy_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIsamax_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIdamax_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIcamax_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIzamax_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIamaxEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIsamin_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIdamin_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIcamin_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIzamin_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasIaminEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasAsumEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSasum_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDasum_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasScasum_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDzasum_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdrot_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasRotEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSrotg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDrotg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCrotg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZrotg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasRotgEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSrotm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDrotm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasRotmEx(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSrotmg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDrotmg_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasRotmgEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            </summary> 
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStpmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtpmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtpmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtpmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStpsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtpsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtpsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtpsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStbsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtbsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtbsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtbsv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsymv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsymv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsymv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsymv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSspmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDspmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChpmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhpmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSger_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDger_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgeru_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgerc_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgeru_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgerc_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCher_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZher_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSspr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDspr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChpr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhpr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCher2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZher2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSspr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDspr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChpr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhpr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsymv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsymv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsymv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsymv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhemv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhbmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSspmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDspmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChpmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhpmv_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSger_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDger_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgeru_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgerc_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgeru_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgerc_v2(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCher_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZher_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSspr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDspr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChpr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhpr_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCher2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZher2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSspr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDspr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChpr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhpr2_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm3m(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm3m(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemm3m(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemm3m(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm3mEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasHgemm(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.half@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.half@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasHgemm(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasHgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.half@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.half@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasHgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemmEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGemmEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.CudaBlas.ComputeType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGemmEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.CudaBlas.ComputeType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemmEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemmEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasUint8gemmBias(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemmEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyrk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyrk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyrk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyrk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyrkEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyrkEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyrk3mEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyrk3mEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCherk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZherk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyr2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyr2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyr2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyr2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCher2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZher2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCherkEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCherk3mEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCherkEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCherk3mEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyrkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyrkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyrkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyrkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCherkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZherkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsymm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsymm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsymm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsymm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrsm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrsm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrsm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrsm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrmm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrmm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrmm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrmm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyrk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyrk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyrk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyrk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCherk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZherk_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyr2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyr2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyr2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyr2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCher2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZher2k_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsyrkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsyrkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsyrkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsyrkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCherkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZherkx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSsymm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDsymm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCsymm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZsymm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasChemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZhemm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrsm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrsm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrsm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrsm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrmm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrmm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrmm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrmm_v2(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgeam(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgeam(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgeam(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgeam(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgeam(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgeam(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgeam(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgeam(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSmatinvBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDmatinvBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCmatinvBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZmatinvBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSdgmm(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDdgmm(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCdgmm(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZdgmm(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm3mBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm3mBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm3mStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemm3mStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGemmBatchedEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int32,ManagedCuda.CudaBlas.ComputeType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGemmStridedBatchedEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,System.Int32,ManagedCuda.CudaBlas.ComputeType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasHgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGemmBatchedEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int32,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGemmStridedBatchedEx(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,System.IntPtr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,System.Int32,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasHgemmStridedBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.half@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,ManagedCuda.BasicTypes.half@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int64,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgetrfBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgetrfBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgetrfBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgetrfBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgetriBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgetriBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgetriBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgetriBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrsmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrsmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrsmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrsmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrsmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrsmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrsmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrsmBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStpttr(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtpttr(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtpttr(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtpttr(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasStrttp(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDtrttp(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCtrttp(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZtrttp(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgeqrfBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgeqrfBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgeqrfBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgeqrfBatched(ManagedCuda.CudaBlas.CudaBlasHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgelsBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgelsBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgelsBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgelsBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSgetrsBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasDgetrsBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasCgetrsBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasZgetrsBatched(ManagedCuda.CudaBlas.CudaBlasHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasLoggerConfigure(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasSetLoggerCallback(ManagedCuda.CudaBlas.cublasLogCallback)">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasNativeMethods.cublasGetLoggerCallback(ManagedCuda.CudaBlas.cublasLogCallback@)">
            <summary>
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.CudaBlasException">
            <summary>
            An CudaBlasException is thrown, if any wrapped call to the CUBLAS-library does not return <see cref="F:ManagedCuda.CudaBlas.CublasStatus.Success"/>.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="serInfo"></param>
            <param name="streamingContext"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasException.#ctor(ManagedCuda.CudaBlas.CublasStatus)">
            <summary>
            
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasException.#ctor(ManagedCuda.CudaBlas.CublasStatus,System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="error"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasException.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlasException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:ManagedCuda.CudaBlas.CudaBlasException.CudaBlasError">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.CudaBlas">
            <summary>
            Wrapper for CUBLAS
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.#ctor">
            <summary>
            Creates a new cudaBlas handler
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.#ctor(ManagedCuda.BasicTypes.CUstream)">
            <summary>
            Creates a new cudaBlas handler
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.#ctor(ManagedCuda.CudaBlas.PointerMode)">
            <summary>
            Creates a new cudaBlas handler
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.#ctor(ManagedCuda.CudaBlas.AtomicsMode)">
            <summary>
            Creates a new cudaBlas handler
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.#ctor(ManagedCuda.BasicTypes.CUstream,ManagedCuda.CudaBlas.PointerMode)">
            <summary>
            Creates a new cudaBlas handler
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.#ctor(ManagedCuda.BasicTypes.CUstream,ManagedCuda.CudaBlas.AtomicsMode)">
            <summary>
            Creates a new cudaBlas handler
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.#ctor(ManagedCuda.CudaBlas.PointerMode,ManagedCuda.CudaBlas.AtomicsMode)">
            <summary>
            Creates a new cudaBlas handler
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.#ctor(ManagedCuda.BasicTypes.CUstream,ManagedCuda.CudaBlas.PointerMode,ManagedCuda.CudaBlas.AtomicsMode)">
            <summary>
            Creates a new cudaBlas handler
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaBlas.CudaBlas.CublasHandle">
            <summary>
            Returns the wrapped cublas handle
            </summary>
        </member>
        <member name="P:ManagedCuda.CudaBlas.CudaBlas.Stream">
            <summary>
            
            </summary>
        </member>
        <member name="P:ManagedCuda.CudaBlas.CudaBlas.PointerMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:ManagedCuda.CudaBlas.CudaBlas.AtomicsMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:ManagedCuda.CudaBlas.CudaBlas.MathMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:ManagedCuda.CudaBlas.CudaBlas.SmCountTarget">
            <summary>
            
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetVersion">
            <summary>
            
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.SetWorkspace(ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="n"></param>
            <param name="x"></param>
            <param name="xType"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="yType"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.float1},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.float1},System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatReal},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatReal},System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.double1},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.double1},System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleReal},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleReal},System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Copy(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function copies the vector x into the vector y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.float1},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.float1},System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatReal},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatReal},System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.double1},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.double1},System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleReal},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleReal},System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Swap(System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32)">
            <summary>
            This function interchanges the elements of vector x and y.
            </summary>
            <param name="n"></param>
            <param name="x"></param>
            <param name="xType"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="yType"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single@)">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double@)">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Single@)">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Double@)">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Norm2(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function computes the Euclidean norm of the vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single@)">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double@)">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function computes the dot product of vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.DotConj(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            This function computes the dot product of vectors x and y.
            <para/>Notice that the conjugate of the element of vector x should be used.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.DotConj(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function computes the dot product of vectors x and y.
            <para/>Notice that the conjugate of the element of vector x should be used.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.DotConj(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function computes the dot product of vectors x and y.
            <para/>Notice that the conjugate of the element of vector x should be used.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.DotConj(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            This function computes the dot product of vectors x and y.
            <para/>Notice that the conjugate of the element of vector x should be used.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.DotConj(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function computes the dot product of vectors x and y.
            <para/>Notice that the conjugate of the element of vector x should be used.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.DotConj(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function computes the dot product of vectors x and y.
            <para/>Notice that the conjugate of the element of vector x should be used.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(System.Single,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(System.Double,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Scale(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function scales the vector x by the scalar and overwrites it with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Axpy(System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function multiplies the vector x by the scalar and adds it to the vector y overwriting
            the latest vector with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Axpy(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function multiplies the vector x by the scalar and adds it to the vector y overwriting
            the latest vector with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Axpy(System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function multiplies the vector x by the scalar and adds it to the vector y overwriting
            the latest vector with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Axpy(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function multiplies the vector x by the scalar and adds it to the vector y overwriting
            the latest vector with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Axpy(ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function multiplies the vector x by the scalar and adds it to the vector y overwriting
            the latest vector with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Axpy(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function multiplies the vector x by the scalar and adds it to the vector y overwriting
            the latest vector with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Axpy(ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function multiplies the vector x by the scalar and adds it to the vector y overwriting
            the latest vector with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Axpy(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function multiplies the vector x by the scalar and adds it to the vector y overwriting
            the latest vector with the result.
            </summary>
            <param name="alpha"></param>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int32@)">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int32@)">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int32@)">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int32@)">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Min(System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the minimum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="n"></param>
            <param name="x"></param>
            <param name="xType"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int32@)">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int32@)">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int32@)">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int32@)">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Max(System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function finds the (smallest) index of the element of the maximum magnitude.<para/>
            First index starts at 1 (Fortran notation)
            </summary>
            <param name="n"></param>
            <param name="x"></param>
            <param name="xType"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single@)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="n"></param>
            <param name="x"></param>
            <param name="xType"></param>
            <param name="incx"></param>
            <param name="result"></param>
            <param name="resultType"></param>
            <param name="executiontype"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double@)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Single@)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Double@)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.AbsoluteSum(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function computes the sum of the absolute values of the elements of vector x.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="result"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,System.Single)">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,System.Double)">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Single,ManagedCuda.VectorTypes.cuFloatComplex)">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Single,System.Single)">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Double,ManagedCuda.VectorTypes.cuDoubleComplex)">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Double,System.Double)">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rot(System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            This function applies Givens rotation matrix G = |c s; -s c| to vectors x and y.
            </summary>
            <param name="n"></param>
            <param name="x"></param>
            <param name="xType"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="yType"></param>
            <param name="incy"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
            <param name="csType"></param>
            <param name="executiontype"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.VectorTypes.cuFloatComplex@,System.Single@,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="abType"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
            <param name="csType"></param>
            <param name="executiontype"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotg(ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.VectorTypes.cuDoubleComplex@,System.Double@,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            This function constructs the Givens rotation matrix G = |c s; -s c| that zeros out the second entry of a 2x1 vector (a; b)T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c">Cosine component</param>
            <param name="s">Sine component</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single[])">
            <summary>
            This function applies the modified Givens transformation H = |h11 h12; h21 h22| to vectors x and y.<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="param"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function applies the modified Givens transformation H = |h11 h12; h21 h22| to vectors x and y.<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="param"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double[])">
            <summary>
            This function applies the modified Givens transformation H = |h11 h12; h21 h22| to vectors x and y.<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="param"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function applies the modified Givens transformation H = |h11 h12; h21 h22| to vectors x and y.<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="param"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            This function applies the modified Givens transformation H = |h11 h12; h21 h22| to vectors x and y.<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="x"></param>
            <param name="incx"></param>
            <param name="y"></param>
            <param name="incy"></param>
            <param name="param"></param>
            <param name="executiontype"></param>
            <param name="n"></param>
            <param name="paramType"></param>
            <param name="xType"></param>
            <param name="yType"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(System.Single@,System.Single@,System.Single@,System.Single,System.Single[])">
            <summary>
            This function constructs the modified Givens transformation H = |h11 h12; h21 h22| that zeros out the second entry of a 2x1 vector 
            [sqrt(d1)*x1; sqrt(d2)*y1].<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="param"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function constructs the modified Givens transformation H = |h11 h12; h21 h22| that zeros out the second entry of a 2x1 vector 
            [sqrt(d1)*x1; sqrt(d2)*y1].<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="param"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(System.Double@,System.Double@,System.Double@,System.Double,System.Double[])">
            <summary>
            This function constructs the modified Givens transformation H = |h11 h12; h21 h22| that zeros out the second entry of a 2x1 vector 
            [sqrt(d1)*x1; sqrt(d2)*y1].<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="param"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary>
            This function constructs the modified Givens transformation H = |h11 h12; h21 h22| that zeros out the second entry of a 2x1 vector 
            [sqrt(d1)*x1; sqrt(d2)*y1].<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="param"></param>
            <param name="d1Type"></param>
            <param name="d2Type"></param>
            <param name="x1Type"></param>
            <param name="y1Type"></param>
            <param name="paramType"></param>
            <param name="executiontype"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Rotm(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function constructs the modified Givens transformation H = |h11 h12; h21 h22| that zeros out the second entry of a 2x1 vector 
            [sqrt(d1)*x1; sqrt(d2)*y1].<para/>
            The elements h11, h21, h12 and h22 of 2x2 matrix H are stored in param[1], param[2], param[3] and param[4], respectively. <para/>
            The flag = param[0] defines the following predefined values for the matrix H entries:<para/>
            flag=-1.0: H = |h11 h12; h21 h22|<para/>
            flag= 0.0: H = |1.0 h12; h21 1.0|<para/> 
            flag= 1.0: H = |h11 1.0; -1.0 h22|<para/>
            flag=-2.0: H = |1.0 0.0; 0.0 1.0|<para/>
            Notice that the values -1.0, 0.0 and 1.0 implied by the flag are not stored in param.
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="param"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the triangular matrix-vector multiplication x= Op(A) x where A is a triangular matrix stored in 
            lower or upper mode with or without the main diagonal, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the triangular matrix-vector multiplication x= Op(A) x where A is a triangular matrix stored in 
            lower or upper mode with or without the main diagonal, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the triangular matrix-vector multiplication x= Op(A) x where A is a triangular matrix stored in 
            lower or upper mode with or without the main diagonal, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the triangular matrix-vector multiplication x= Op(A) x where A is a triangular matrix stored in 
            lower or upper mode with or without the main diagonal, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tbmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the triangular banded matrix-vector multiplication x= Op(A) x where A is a triangular banded matrix, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tbmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the triangular banded matrix-vector multiplication x= Op(A) x where A is a triangular banded matrix, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tbmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the triangular banded matrix-vector multiplication x= Op(A) x where A is a triangular banded matrix, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tbmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the triangular banded matrix-vector multiplication x= Op(A) x where A is a triangular banded matrix, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tpmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the triangular packed matrix-vector multiplication x= Op(A) x where A is a triangular matrix stored in packed format, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tpmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the triangular packed matrix-vector multiplication x= Op(A) x where A is a triangular matrix stored in packed format, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tpmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the triangular packed matrix-vector multiplication x= Op(A) x where A is a triangular matrix stored in packed format, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tpmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the triangular packed matrix-vector multiplication x= Op(A) x where A is a triangular matrix stored in packed format, and x is a vector. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function solves the triangular linear system with a single right-hand-side Op(A)x = b where A is a triangular matrix stored in lower or 
            upper mode with or without the main diagonal, and x and b are vectors. The solution x overwrites the right-hand-sides b on exit. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function solves the triangular linear system with a single right-hand-side Op(A)x = b where A is a triangular matrix stored in lower or 
            upper mode with or without the main diagonal, and x and b are vectors. The solution x overwrites the right-hand-sides b on exit. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function solves the triangular linear system with a single right-hand-side Op(A)x = b where A is a triangular matrix stored in lower or 
            upper mode with or without the main diagonal, and x and b are vectors. The solution x overwrites the right-hand-sides b on exit. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function solves the triangular linear system with a single right-hand-side Op(A)x = b where A is a triangular matrix stored in lower or 
            upper mode with or without the main diagonal, and x and b are vectors. The solution x overwrites the right-hand-sides b on exit. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tpsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function solves the packed triangular linear system with a single right-hand-side Op(A) x = b where A is a triangular matrix stored in packed format, and x and b are vectors. 
            The solution x overwrites the right-hand-sides b on exit. n is given by x.Size. No test for singularity or near-singularity is included in this function.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tpsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function solves the packed triangular linear system with a single right-hand-side Op(A) x = b where A is a triangular matrix stored in packed format, and x and b are vectors. 
            The solution x overwrites the right-hand-sides b on exit. n is given by x.Size. No test for singularity or near-singularity is included in this function.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tpsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function solves the packed triangular linear system with a single right-hand-side Op(A) x = b where A is a triangular matrix stored in packed format, and x and b are vectors. 
            The solution x overwrites the right-hand-sides b on exit. n is given by x.Size. No test for singularity or near-singularity is included in this function.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tpsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function solves the packed triangular linear system with a single right-hand-side Op(A) x = b where A is a triangular matrix stored in packed format, and x and b are vectors. 
            The solution x overwrites the right-hand-sides b on exit. n is given by x.Size. No test for singularity or near-singularity is included in this function.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tbsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function solves the triangular banded linear system with a single right-hand-side Op(A) x = b where A is a triangular banded matrix, and x and b is a vector. 
            The solution x overwrites the right-hand-sides b on exit. n is given by x.Size. No test for singularity or near-singularity is included in this function.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tbsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function solves the triangular banded linear system with a single right-hand-side Op(A) x = b where A is a triangular banded matrix, and x and b is a vector. 
            The solution x overwrites the right-hand-sides b on exit. n is given by x.Size. No test for singularity or near-singularity is included in this function.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tbsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function solves the triangular banded linear system with a single right-hand-side Op(A) x = b where A is a triangular banded matrix, and x and b is a vector. 
            The solution x overwrites the right-hand-sides b on exit. n is given by x.Size. No test for singularity or near-singularity is included in this function.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Tbsv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function solves the triangular banded linear system with a single right-hand-side Op(A) x = b where A is a triangular banded matrix, and x and b is a vector. 
            The solution x overwrites the right-hand-sides b on exit. n is given by x.Size. No test for singularity or near-singularity is included in this function.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gbmv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="kl">number of subdiagonals of matrix A.</param>
            <param name="ku">number of superdiagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gbmv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="kl">number of subdiagonals of matrix A.</param>
            <param name="ku">number of superdiagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gbmv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="kl">number of subdiagonals of matrix A.</param>
            <param name="ku">number of superdiagonals of matrix A.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gbmv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="kl">number of subdiagonals of matrix A.</param>
            <param name="ku">number of superdiagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gbmv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="kl">number of subdiagonals of matrix A.</param>
            <param name="ku">number of superdiagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gbmv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="kl">number of subdiagonals of matrix A.</param>
            <param name="ku">number of superdiagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gbmv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="kl">number of subdiagonals of matrix A.</param>
            <param name="ku">number of superdiagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gbmv(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-vector multiplication y = alpha * Op(A) * x + beta * y where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha and beta are scalars.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="kl">number of subdiagonals of matrix A.</param>
            <param name="ku">number of superdiagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symv(ManagedCuda.CudaBlas.FillMode,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symv(ManagedCuda.CudaBlas.FillMode,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric matrix-vector multiplication y = alpha *A * x + beta * y where A is a n*n symmetric matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric matrix-vector multiplication y = alpha *A * x + beta * y where A is a n*n symmetric matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hemv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hemv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hemv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hemv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix stored in lower or upper mode, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Sbmv(ManagedCuda.CudaBlas.FillMode,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric banded matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix with k subdiagonals and superdiagonals, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Sbmv(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric banded matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix with k subdiagonals and superdiagonals, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Sbmv(ManagedCuda.CudaBlas.FillMode,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric banded matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix with k subdiagonals and superdiagonals, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Sbmv(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric banded matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix with k subdiagonals and superdiagonals, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hbmv(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian banded matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix with k subdiagonals and superdiagonals, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hbmv(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric banded matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix with k subdiagonals and superdiagonals, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hbmv(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric banded matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix with k subdiagonals and superdiagonals, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hbmv(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric banded matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix with k subdiagonals and superdiagonals, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="k">number of sub- and super-diagonals of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spmv(ManagedCuda.CudaBlas.FillMode,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric packed matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in packed format, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric packed matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in packed format, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spmv(ManagedCuda.CudaBlas.FillMode,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric packed matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in packed format, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric packed matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n symmetric matrix stored in packed format, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian packed matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix stored in packed format, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian packed matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix stored in packed format, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian packed matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix stored in packed format, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpmv(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian packed matrix-vector multiplication y = alpha * A * x + beta * y where A is a n*n Hermitian matrix stored in packed format, 
            x and y are vectors, and alpha and beta are scalars. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="AP">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="beta">scalar used for multiplication, if beta==0 then y does not have to be a valid input.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Ger(System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^T + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Ger(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^T + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Ger(System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^T + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Ger(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^T + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GerU(ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^T + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GerU(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^T + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GerC(ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^H + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GerC(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^H + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GerU(ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^T + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GerU(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^T + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GerC(ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^H + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GerC(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the rank-1 update A = alpha * x * y^H + A where A is a m*n matrix stored in column-major format, 
            x and y are vectors, and alpha is a scalar. m = x.Size, n = y.Size.
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr(ManagedCuda.CudaBlas.FillMode,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr(ManagedCuda.CudaBlas.FillMode,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her(ManagedCuda.CudaBlas.FillMode,System.Single,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-1 update A = alpha * x * x^H + A where A is a n*n Hermitian Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-1 update A = alpha * x * x^H + A where A is a n*n Hermitian Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her(ManagedCuda.CudaBlas.FillMode,System.Double,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-1 update A = alpha * x * x^H + A where A is a n*n Hermitian Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-1 update A = alpha * x * x^H + A where A is a n*n Hermitian Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spr(ManagedCuda.CudaBlas.FillMode,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spr(ManagedCuda.CudaBlas.FillMode,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the symmetric rank-1 update A = alpha * x * x^T + A where A is a n*n symmetric Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpr(ManagedCuda.CudaBlas.FillMode,System.Single,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the Hermitian rank-1 update A = alpha * x * x^H + A where A is a n*n Hermitian Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the Hermitian rank-1 update A = alpha * x * x^H + A where A is a n*n Hermitian Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpr(ManagedCuda.CudaBlas.FillMode,System.Double,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the Hermitian rank-1 update A = alpha * x * x^H + A where A is a n*n Hermitian Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpr(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the Hermitian rank-1 update A = alpha * x * x^H + A where A is a n*n Hermitian Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2(ManagedCuda.CudaBlas.FillMode,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2(ManagedCuda.CudaBlas.FillMode,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-2 update A = alpha * (x * y^T + y * y^T) + A where A is a n*n symmetric Matrix stored in column-major format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of y.</param>
            <param name="A">array of dimensions lda * n, with lda >= max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spr2(ManagedCuda.CudaBlas.FillMode,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the packed symmetric rank-2 update A = alpha * (x * y^T + y * x^T) + A where A is a n*n symmetric Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the packed symmetric rank-2 update A = alpha * (x * y^T + y * x^T) + A where A is a n*n symmetric Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spr2(ManagedCuda.CudaBlas.FillMode,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the packed symmetric rank-2 update A = alpha * (x * y^T + y * x^T) + A where A is a n*n symmetric Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Spr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the packed symmetric rank-2 update A = alpha * (x * y^T + y * x^T) + A where A is a n*n symmetric Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size = y.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the packed Hermitian rank-2 update A = alpha * (x * y^H + y * x^H) + A where A is a n*n Hermitian Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the packed Hermitian rank-2 update A = alpha * (x * y^H + y * x^H) + A where A is a n*n Hermitian Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the packed Hermitian rank-2 update A = alpha * (x * y^H + y * x^H) + A where A is a n*n Hermitian Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hpr2(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the packed Hermitian rank-2 update A = alpha * (x * y^H + y * x^H) + A where A is a n*n Hermitian Matrix stored in packed format,
            x is a vector, and alpha is a scalar. n is given by x.Size.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">vector with n elements.</param>
            <param name="incx">stride between consecutive elements of x.</param>
            <param name="y">vector with n elements.</param>
            <param name="incy">stride between consecutive elements of x.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.half,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,ManagedCuda.BasicTypes.half,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmEx(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32,System.Single,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Atype">enumerant specifying the datatype of matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="Btype">enumerant specifying the datatype of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
            <param name="Ctype">enumerant specifying the datatype of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmEx(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaBlas.DataType,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = alpha * Op(A) * Op(B) + beta * C where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*k, op(B) k*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Atype">enumerant specifying the datatype of matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="Btype">enumerant specifying the datatype of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
            <param name="Ctype">enumerant specifying the datatype of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * Op(A)*Op(A)^T + beta * C where
            alpha and beta are scalars, and A, B and C are matrices stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * Op(A)*Op(A)^T + beta * C where
            alpha and beta are scalars, and A, B and C are matrices stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * Op(A)*Op(A)^T + beta * C where
            alpha and beta are scalars, and A, B and C are matrices stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * Op(A)*Op(A)^T + beta * C where
            alpha and beta are scalars, and A, B and C are matrices stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * Op(A)*Op(A)^T + beta * C where
            alpha and beta are scalars, and A, B and C are matrices stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * Op(A)*Op(A)^T + beta * C where
            alpha and beta are scalars, and A, B and C are matrices stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * Op(A)*Op(A)^T + beta * C where
            alpha and beta are scalars, and A, B and C are matrices stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * Op(A)*Op(A)^T + beta * C where
            alpha and beta are scalars, and A, B and C are matrices stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Herk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-k update C = alpha * Op(A)*Op(A)^H + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Herk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-k update C = alpha * Op(A)*Op(A)^H + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Herk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-k update C = alpha * Op(A)*Op(A)^H + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Herk(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-k update C = alpha * Op(A)*Op(A)^H + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * (Op(A)*Op(B)^T + Op(B)*Op(A)^T) + beta * C where
            alpha and beta are scalars, and C is a symmetrux matrix stored in lower or upper mode, and A and B are matrices with dimensions Op(A) n*k
            and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * (Op(A)*Op(B)^T + Op(B)*Op(A)^T) + beta * C where
            alpha and beta are scalars, and C is a symmetrux matrix stored in lower or upper mode, and A and B are matrices with dimensions Op(A) n*k
            and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * (Op(A)*Op(B)^T + Op(B)*Op(A)^T) + beta * C where
            alpha and beta are scalars, and C is a symmetrux matrix stored in lower or upper mode, and A and B are matrices with dimensions Op(A) n*k
            and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * (Op(A)*Op(B)^T + Op(B)*Op(A)^T) + beta * C where
            alpha and beta are scalars, and C is a symmetrux matrix stored in lower or upper mode, and A and B are matrices with dimensions Op(A) n*k
            and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * (Op(A)*Op(B)^T + Op(B)*Op(A)^T) + beta * C where
            alpha and beta are scalars, and C is a symmetrux matrix stored in lower or upper mode, and A and B are matrices with dimensions Op(A) n*k
            and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * (Op(A)*Op(B)^T + Op(B)*Op(A)^T) + beta * C where
            alpha and beta are scalars, and C is a symmetrux matrix stored in lower or upper mode, and A and B are matrices with dimensions Op(A) n*k
            and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * (Op(A)*Op(B)^T + Op(B)*Op(A)^T) + beta * C where
            alpha and beta are scalars, and C is a symmetrux matrix stored in lower or upper mode, and A and B are matrices with dimensions Op(A) n*k
            and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syr2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric rank-k update C = alpha * (Op(A)*Op(B)^T + Op(B)*Op(A)^T) + beta * C where
            alpha and beta are scalars, and C is a symmetrux matrix stored in lower or upper mode, and A and B are matrices with dimensions Op(A) n*k
            and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-k update C = alpha * (Op(A)*Op(B)^H + Op(B)*Op(A)^H) + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-k update C = alpha * (Op(A)*Op(B)^H + Op(B)*Op(A)^H) + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-k update C = alpha * (Op(A)*Op(B)^H + Op(B)*Op(A)^H) + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Her2k(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian rank-k update C = alpha * (Op(A)*Op(B)^H + Op(B)*Op(A)^H) + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A is a matrix with dimensions op(A) n*k and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="k">number of columns of op(A) and rows of op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * k.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single@,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs a variation of the symmetric rank- update C = alpha * (Op(A)*Op(B))^T + beta * C where alpha 
            and beta are scalars, C is a symmetric matrix stored in lower or upper mode, and A
            and B are matrices with dimensions op(A) n*k and op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication, if beta==0, then C does not have to be a valid input.</param>
            <param name="C">array of dimensions ldc x n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double@,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs a variation of the symmetric rank- update C = alpha * (Op(A)*Op(B))^T + beta * C where alpha 
            and beta are scalars, C is a symmetric matrix stored in lower or upper mode, and A
            and B are matrices with dimensions op(A) n*k and op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication, if beta==0, then C does not have to be a valid input.</param>
            <param name="C">array of dimensions ldc x n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs a variation of the symmetric rank- update C = alpha * (Op(A)*Op(B))^T + beta * C where alpha 
            and beta are scalars, C is a symmetric matrix stored in lower or upper mode, and A
            and B are matrices with dimensions op(A) n*k and op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication, if beta==0, then C does not have to be a valid input.</param>
            <param name="C">array of dimensions ldc x n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs a variation of the symmetric rank- update C = alpha * (Op(A)*Op(B))^T + beta * C where alpha 
            and beta are scalars, C is a symmetric matrix stored in lower or upper mode, and A
            and B are matrices with dimensions op(A) n*k and op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication, if beta==0, then C does not have to be a valid input.</param>
            <param name="C">array of dimensions ldc x n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs a variation of the symmetric rank- update C = alpha * (Op(A)*Op(B))^T + beta * C where alpha 
            and beta are scalars, C is a symmetric matrix stored in lower or upper mode, and A
            and B are matrices with dimensions op(A) n*k and op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication, if beta==0, then C does not have to be a valid input.</param>
            <param name="C">array of dimensions ldc x n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs a variation of the symmetric rank- update C = alpha * (Op(A)*Op(B))^T + beta * C where alpha 
            and beta are scalars, C is a symmetric matrix stored in lower or upper mode, and A
            and B are matrices with dimensions op(A) n*k and op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication, if beta==0, then C does not have to be a valid input.</param>
            <param name="C">array of dimensions ldc x n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs a variation of the symmetric rank- update C = alpha * (Op(A)*Op(B))^T + beta * C where alpha 
            and beta are scalars, C is a symmetric matrix stored in lower or upper mode, and A
            and B are matrices with dimensions op(A) n*k and op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication, if beta==0, then C does not have to be a valid input.</param>
            <param name="C">array of dimensions ldc x n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Syrkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs a variation of the symmetric rank- update C = alpha * (Op(A)*Op(B))^T + beta * C where alpha 
            and beta are scalars, C is a symmetric matrix stored in lower or upper mode, and A
            and B are matrices with dimensions op(A) n*k and op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix C lower or upper part, is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication, if beta==0, then C does not have to be a valid input.</param>
            <param name="C">array of dimensions ldc x n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Herkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Single@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs a variation of the Hermitian rank-k update C = alpha * Op(A) * Op(B)^H + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n*k and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">real scalar used for multiplication, if beta==0 then C does not have to be a valid input.</param>
            <param name="C">array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Herkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Double@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs a variation of the Hermitian rank-k update C = alpha * Op(A) * Op(B)^H + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n*k and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">real scalar used for multiplication, if beta==0 then C does not have to be a valid input.</param>
            <param name="C">array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Herkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs a variation of the Hermitian rank-k update C = alpha * Op(A) * Op(B)^H + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n*k and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">real scalar used for multiplication, if beta==0 then C does not have to be a valid input.</param>
            <param name="C">array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Herkx(ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs a variation of the Hermitian rank-k update C = alpha * Op(A) * Op(B)^H + beta * C where
            alpha and beta are scalars, and C is a Hermitian matrix stored in lower or upper mode, and A and B are matrices with dimensions op(A) n*k and Op(B) n*k, respectively.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other Hermitian part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows of matrix op(A), op(B) and C.</param>
            <param name="k">number of columns of matrix op(A) and op(B).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimension lda x k with lda>=max(1,n) if transa == CUBLAS_OP_N and lda x n with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb x k with ldb>=max(1,n) if transa == CUBLAS_OP_N and ldb x n with ldb>=max(1,k) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">real scalar used for multiplication, if beta==0 then C does not have to be a valid input.</param>
            <param name="C">array of dimension ldc x n, with ldc>=max(1,n). The imaginary parts of the diagonal elements are assumed and set to zero.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a symmetric matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the symmetric matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a symmetric matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a symmetric matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the symmetric matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a symmetric matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a symmetric matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the symmetric matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a symmetric matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a symmetric matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Symm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the symmetric matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a symmetric matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hemm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a Hermitian matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hemm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the Hermitian matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a Hermitian matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hemm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a Hermitian matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Hemm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the Hermitian matrix-matrix multiplication C = alpha*A*B + beta*C if side==SideMode.Left or C = alpha*B*A + beta*C if side==SideMode.Right 
            where A is a Hermitian matrix stored in lower or upper mode, B and C are m*n matrices, and alpha and beta are scalars.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of B.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function solves the triangular linear system with multiple right-hand-sides Op(A)X = alpha*B side==SideMode.Left or XOp(A) = alpha*B if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the maindiagonal, X and B are m*n matrices, and alpha is a scalar.<para/>
            The solution X overwrites the right-hand-sides B on exit.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function solves the triangular linear system with multiple right-hand-sides Op(A)X = alpha*B side==SideMode.Left or XOp(A) = alpha*B if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the maindiagonal, X and B are m*n matrices, and alpha is a scalar.<para/>
            The solution X overwrites the right-hand-sides B on exit.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function solves the triangular linear system with multiple right-hand-sides Op(A)X = alpha*B side==SideMode.Left or XOp(A) = alpha*B if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the maindiagonal, X and B are m*n matrices, and alpha is a scalar.<para/>
            The solution X overwrites the right-hand-sides B on exit.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function solves the triangular linear system with multiple right-hand-sides Op(A)X = alpha*B side==SideMode.Left or XOp(A) = alpha*B if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the maindiagonal, X and B are m*n matrices, and alpha is a scalar.<para/>
            The solution X overwrites the right-hand-sides B on exit.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function solves the triangular linear system with multiple right-hand-sides Op(A)X = alpha*B side==SideMode.Left or XOp(A) = alpha*B if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the maindiagonal, X and B are m*n matrices, and alpha is a scalar.<para/>
            The solution X overwrites the right-hand-sides B on exit.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function solves the triangular linear system with multiple right-hand-sides Op(A)X = alpha*B side==SideMode.Left or XOp(A) = alpha*B if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the maindiagonal, X and B are m*n matrices, and alpha is a scalar.<para/>
            The solution X overwrites the right-hand-sides B on exit.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function solves the triangular linear system with multiple right-hand-sides Op(A)X = alpha*B side==SideMode.Left or XOp(A) = alpha*B if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the maindiagonal, X and B are m*n matrices, and alpha is a scalar.<para/>
            The solution X overwrites the right-hand-sides B on exit.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function solves the triangular linear system with multiple right-hand-sides Op(A)X = alpha*B side==SideMode.Left or XOp(A) = alpha*B if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the maindiagonal, X and B are m*n matrices, and alpha is a scalar.<para/>
            The solution X overwrites the right-hand-sides B on exit.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the triangular matrix-matrix multiplication C = alpha*Op(A) * B if side==SideMode.Left or C = alpha*B * Op(A) if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m*n matrices, and alpha is a scalar.<para/>
            Notice that in order to achieve better parallelism CUBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results
            written back to B), while the CUBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in
            the CUBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the triangular matrix-matrix multiplication C = alpha*Op(A) * B if side==SideMode.Left or C = alpha*B * Op(A) if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m*n matrices, and alpha is a scalar.<para/>
            Notice that in order to achieve better parallelism CUBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results
            written back to B), while the CUBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in
            the CUBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the triangular matrix-matrix multiplication C = alpha*Op(A) * B if side==SideMode.Left or C = alpha*B * Op(A) if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m*n matrices, and alpha is a scalar.<para/>
            Notice that in order to achieve better parallelism CUBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results
            written back to B), while the CUBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in
            the CUBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the triangular matrix-matrix multiplication C = alpha*Op(A) * B if side==SideMode.Left or C = alpha*B * Op(A) if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m*n matrices, and alpha is a scalar.<para/>
            Notice that in order to achieve better parallelism CUBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results
            written back to B), while the CUBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in
            the CUBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the triangular matrix-matrix multiplication C = alpha*Op(A) * B if side==SideMode.Left or C = alpha*B * Op(A) if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m*n matrices, and alpha is a scalar.<para/>
            Notice that in order to achieve better parallelism CUBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results
            written back to B), while the CUBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in
            the CUBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the triangular matrix-matrix multiplication C = alpha*Op(A) * B if side==SideMode.Left or C = alpha*B * Op(A) if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m*n matrices, and alpha is a scalar.<para/>
            Notice that in order to achieve better parallelism CUBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results
            written back to B), while the CUBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in
            the CUBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the triangular matrix-matrix multiplication C = alpha*Op(A) * B if side==SideMode.Left or C = alpha*B * Op(A) if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m*n matrices, and alpha is a scalar.<para/>
            Notice that in order to achieve better parallelism CUBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results
            written back to B), while the CUBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in
            the CUBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Trsm(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the triangular matrix-matrix multiplication C = alpha*Op(A) * B if side==SideMode.Left or C = alpha*B * Op(A) if side==SideMode.Right 
            where A is a triangular matrix stored in lower or upper mode with or without the main diagonal, B and C are m*n matrices, and alpha is a scalar.<para/>
            Notice that in order to achieve better parallelism CUBLAS differs from the BLAS API only for this routine. The BLAS API assumes an in-place implementation (with results
            written back to B), while the CUBLAS API assumes an out-of-place implementation (with results written into C). The application can obtain the in-place functionality of BLAS in
            the CUBLAS API by passing the address of the matrix B in place of the matrix C. No other overlapping in the input parameters is supported.
            </summary>
            <param name="side">indicates if matrix A is on the left or right of X.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
            <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
            <param name="alpha">scalar used for multiplication. If alpha==0 then A is not referenced and B does not have to be a valid input.</param>
            <param name="A">array of dimensions lda * m.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="C">array of dimensions ldc * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Geam(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-matrix addition/transposition C = alpha * Op(A) + beta * Op(B) where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*n, op(B) m*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Geam(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-matrix addition/transposition C = alpha * Op(A) + beta * Op(B) where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*n, op(B) m*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Geam(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix addition/transposition C = alpha * Op(A) + beta * Op(B) where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*n, op(B) m*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Geam(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix addition/transposition C = alpha * Op(A) + beta * Op(B) where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*n, op(B) m*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Geam(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-matrix addition/transposition C = alpha * Op(A) + beta * Op(B) where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*n, op(B) m*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Geam(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-matrix addition/transposition C = alpha * Op(A) + beta * Op(B) where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*n, op(B) m*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Geam(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix addition/transposition C = alpha * Op(A) + beta * Op(B) where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*n, op(B) m*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Geam(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix addition/transposition C = alpha * Op(A) + beta * Op(B) where 
            alpha and beta are scalars, and A, B and C are matrices stored in column-major format with dimensions 
            op(A) m*n, op(B) m*n and C m*n, respectively.
            </summary>
            <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A) and C.</param>
            <param name="n">number of columns of matrix op(B) and C.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">array of dimensions lda * k.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimensions ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="C">array of dimensions ldb * n.</param>
            <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.MatinvBatchedS(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <param name="A"></param>
            <param name="lda"></param>
            <param name="Ainv"></param>
            <param name="lda_inv"></param>
            <param name="INFO"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.MatinvBatchedD(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <param name="A"></param>
            <param name="lda"></param>
            <param name="Ainv"></param>
            <param name="lda_inv"></param>
            <param name="INFO"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.MatinvBatchedC(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <param name="A"></param>
            <param name="lda"></param>
            <param name="Ainv"></param>
            <param name="lda_inv"></param>
            <param name="INFO"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.MatinvBatchedZ(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <param name="A"></param>
            <param name="lda"></param>
            <param name="Ainv"></param>
            <param name="lda_inv"></param>
            <param name="INFO"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dgmm(ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = A x diag(X) if mode == CUBLAS_SIDE_RIGHT, or 
            C = diag(X) x A if mode == CUBLAS_SIDE_LEFT.<para/>
            where A and C are matrices stored in column-major format with dimensions m*n. X is a
            vector of size n if mode == CUBLAS_SIDE_RIGHT and of size m if mode ==
            CUBLAS_SIDE_LEFT. X is gathered from one-dimensional array x with stride incx. The
            absolute value of incx is the stride and the sign of incx is direction of the stride. If incx
            is positive, then we forward x from the first element. Otherwise, we backward x from the
            last element.
            </summary>
            <param name="mode">left multiply if mode == CUBLAS_SIDE_LEFT 
            or right multiply if mode == CUBLAS_SIDE_RIGHT</param>
            <param name="m">number of rows of matrix A and C.</param>
            <param name="n">number of columns of matrix A and C.</param>
            <param name="A">array of dimensions lda x n with lda >= max(1,m)</param>
            <param name="lda">leading dimension of two-dimensional array used to store the matrix A.</param>
            <param name="X">one-dimensional array of size |incx|*m 
            if mode == CUBLAS_SIDE_LEFT and |incx|*n
            if mode == CUBLAS_SIDE_RIGHT</param>
            <param name="incx">stride of one-dimensional array x.</param>
            <param name="C">array of dimensions ldc*n with ldc >= max(1,m).</param>
            <param name="ldc">leading dimension of a two-dimensional array used to store the matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dgmm(ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = A x diag(X) if mode == CUBLAS_SIDE_RIGHT, or 
            C = diag(X) x A if mode == CUBLAS_SIDE_LEFT.<para/>
            where A and C are matrices stored in column-major format with dimensions m*n. X is a
            vector of size n if mode == CUBLAS_SIDE_RIGHT and of size m if mode ==
            CUBLAS_SIDE_LEFT. X is gathered from one-dimensional array x with stride incx. The
            absolute value of incx is the stride and the sign of incx is direction of the stride. If incx
            is positive, then we forward x from the first element. Otherwise, we backward x from the
            last element.
            </summary>
            <param name="mode">left multiply if mode == CUBLAS_SIDE_LEFT 
            or right multiply if mode == CUBLAS_SIDE_RIGHT</param>
            <param name="m">number of rows of matrix A and C.</param>
            <param name="n">number of columns of matrix A and C.</param>
            <param name="A">array of dimensions lda x n with lda >= max(1,m)</param>
            <param name="lda">leading dimension of two-dimensional array used to store the matrix A.</param>
            <param name="X">one-dimensional array of size |incx|*m 
            if mode == CUBLAS_SIDE_LEFT and |incx|*n
            if mode == CUBLAS_SIDE_RIGHT</param>
            <param name="incx">stride of one-dimensional array x.</param>
            <param name="C">array of dimensions ldc*n with ldc >= max(1,m).</param>
            <param name="ldc">leading dimension of a two-dimensional array used to store the matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dgmm(ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = A x diag(X) if mode == CUBLAS_SIDE_RIGHT, or 
            C = diag(X) x A if mode == CUBLAS_SIDE_LEFT.<para/>
            where A and C are matrices stored in column-major format with dimensions m*n. X is a
            vector of size n if mode == CUBLAS_SIDE_RIGHT and of size m if mode ==
            CUBLAS_SIDE_LEFT. X is gathered from one-dimensional array x with stride incx. The
            absolute value of incx is the stride and the sign of incx is direction of the stride. If incx
            is positive, then we forward x from the first element. Otherwise, we backward x from the
            last element.
            </summary>
            <param name="mode">left multiply if mode == CUBLAS_SIDE_LEFT 
            or right multiply if mode == CUBLAS_SIDE_RIGHT</param>
            <param name="m">number of rows of matrix A and C.</param>
            <param name="n">number of columns of matrix A and C.</param>
            <param name="A">array of dimensions lda x n with lda >= max(1,m)</param>
            <param name="lda">leading dimension of two-dimensional array used to store the matrix A.</param>
            <param name="X">one-dimensional array of size |incx|*m 
            if mode == CUBLAS_SIDE_LEFT and |incx|*n
            if mode == CUBLAS_SIDE_RIGHT</param>
            <param name="incx">stride of one-dimensional array x.</param>
            <param name="C">array of dimensions ldc*n with ldc >= max(1,m).</param>
            <param name="ldc">leading dimension of a two-dimensional array used to store the matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dgmm(ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication C = A x diag(X) if mode == CUBLAS_SIDE_RIGHT, or 
            C = diag(X) x A if mode == CUBLAS_SIDE_LEFT.<para/>
            where A and C are matrices stored in column-major format with dimensions m*n. X is a
            vector of size n if mode == CUBLAS_SIDE_RIGHT and of size m if mode ==
            CUBLAS_SIDE_LEFT. X is gathered from one-dimensional array x with stride incx. The
            absolute value of incx is the stride and the sign of incx is direction of the stride. If incx
            is positive, then we forward x from the first element. Otherwise, we backward x from the
            last element.
            </summary>
            <param name="mode">left multiply if mode == CUBLAS_SIDE_LEFT 
            or right multiply if mode == CUBLAS_SIDE_RIGHT</param>
            <param name="m">number of rows of matrix A and C.</param>
            <param name="n">number of columns of matrix A and C.</param>
            <param name="A">array of dimensions lda x n with lda >= max(1,m)</param>
            <param name="lda">leading dimension of two-dimensional array used to store the matrix A.</param>
            <param name="X">one-dimensional array of size |incx|*m 
            if mode == CUBLAS_SIDE_LEFT and |incx|*n
            if mode == CUBLAS_SIDE_RIGHT</param>
            <param name="incx">stride of one-dimensional array x.</param>
            <param name="C">array of dimensions ldc*n with ldc >= max(1,m).</param>
            <param name="ldc">leading dimension of a two-dimensional array used to store the matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int32,ManagedCuda.CudaBlas.ComputeType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
            <param name="algo"></param>
            <param name="Atype"></param>
            <param name="Btype"></param>
            <param name="computeType"></param>
            <param name="Ctype"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,System.Int32,ManagedCuda.CudaBlas.ComputeType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to <![CDATA[<Atype>]]> matrix, A, corresponds to the first instance of the batch of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="strideA">value of type long long int that gives the address offset between A[i] and A[i+1]. </param>
            <param name="strideB">value of type long long int that gives the address offset between B[i] and B[i+1]. </param>
            <param name="strideC">value of type long long int that gives the address offset between C[i] and C[i+1]. </param>
            <param name="B">pointer to <![CDATA[<Btype>]]> matrix, A, corresponds to the first instance of the batch of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to <![CDATA[<Ctype>]]> matrix, A, corresponds to the first instance of the batch. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
            <param name="algo"></param>
            <param name="Atype"></param>
            <param name="Btype"></param>
            <param name="computeType"></param>
            <param name="Ctype"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm3mBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the complex matrix-matrix multiplication, using Gauss complexity reduction algorithm. This can lead to an increase in performance up to 25% <para/>
            C = a op(A ) op(B ) +  C <para/>
            where a and b are scalars, and A , B and C are matrices stored in column-major format with dimensions op(A ) m k, op ( B ) k n and C m n, respectively. Also, for matrix A
            op(A ) = A if  transa == CUBLAS_OP_N A T if  transa == CUBLAS_OP_T A H if  transa == CUBLAS_OP_C
            and op(B ) is defined similarly for matrix B. <para/>
            Note: These 2 routines are only supported on GPUs with architecture capabilities equal or greater than 5.0 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.half,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.BasicTypes.half,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.IntPtr,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},ManagedCuda.BasicTypes.cudaDataType,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.IntPtr,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int32,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
            <param name="algo"></param>
            <param name="Atype"></param>
            <param name="Btype"></param>
            <param name="computeType"></param>
            <param name="Ctype"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,System.IntPtr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.Int32,System.Int64,System.Int32,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaBlas.GemmAlgo)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to <![CDATA[<Atype>]]> matrix, A, corresponds to the first instance of the batch of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="strideA">value of type long long int that gives the address offset between A[i] and A[i+1]. </param>
            <param name="strideB">value of type long long int that gives the address offset between B[i] and B[i+1]. </param>
            <param name="strideC">value of type long long int that gives the address offset between C[i] and C[i+1]. </param>
            <param name="B">pointer to <![CDATA[<Btype>]]> matrix, A, corresponds to the first instance of the batch of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to <![CDATA[<Ctype>]]> matrix, A, corresponds to the first instance of the batch. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
            <param name="algo"></param>
            <param name="Atype"></param>
            <param name="Btype"></param>
            <param name="computeType"></param>
            <param name="Ctype"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Gemm3mBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the complex matrix-matrix multiplication, using Gauss complexity reduction algorithm. This can lead to an increase in performance up to 25% <para/>
            C = a op(A ) op(B ) +  C <para/>
            where a and b are scalars, and A , B and C are matrices stored in column-major format with dimensions op(A ) m k, op ( B ) k n and C m n, respectively. Also, for matrix A
            op(A ) = A if  transa == CUBLAS_OP_N A T if  transa == CUBLAS_OP_T A H if  transa == CUBLAS_OP_C
            and op(B ) is defined similarly for matrix B. <para/>
            Note: These 2 routines are only supported on GPUs with architecture capabilities equal or greater than 5.0 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplications of an array of matrices.
            where and are scalars, and , and are arrays of pointers to matrices stored
            in column-major format with dimensions op(A[i])m x k, op(B[i])k x n and op(C[i])m x n, 
            respectively.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. For small sizes, typically smaller than 100x100,
            this function improves significantly performance compared to making calls to its
            corresponding cublas<![CDATA[<type>]]>gemm routine. However, on GPU architectures that support
            concurrent kernels, it might be advantageous to make multiple calls to cublas<![CDATA[<type>]]>gemm
            into different streams as the matrix sizes increase.
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix op(A[i]) and C[i].</param>
            <param name="n">number of columns of op(B[i]) and C[i].</param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="Aarray">array of device pointers, with each array/device pointer of dim. lda x k with lda>=max(1,m) if
            transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="Barray">array of device pointers, with each array of dim. ldb x n with ldb>=max(1,k) if
            transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i].</param>
            <param name="beta">scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="Carray">array of device pointers. It has dimensions ldc x n with ldc>=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i].</param>
            <param name="batchCount">number of pointers contained in A, B and C.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int64,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int64,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int64,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int64,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GemmStridedBatched(ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.half,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,System.Int64,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,System.Int64,ManagedCuda.BasicTypes.half,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.half},System.Int32,System.Int64,System.Int32)">
            <summary>
            This function performs the matrix-matrix multiplication of a batch of matrices. The batch is considered to be "uniform", 
            i.e. all instances have the same dimensions (m, n, k), leading dimensions (lda, ldb, ldc) and transpositions (transa, transb) 
            for their respective A, B and C matrices. Input matrices A, B and output matrix C for each instance of the batch are located 
            at fixed address offsets from their locations in the previous instance. Pointers to A, B and C matrices for the first 
            instance are passed to the function by the user along with the address offsets - strideA, strideB and strideC that determine 
            the locations of input and output matrices in future instances. 
            </summary>
            <param name="transa">operation op(A[i]) that is non- or (conj.) transpose. </param>
            <param name="transb">operation op(B[i]) that is non- or (conj.) transpose. </param>
            <param name="m">number of rows of matrix op(A[i]) and C[i]. </param>
            <param name="n">number of columns of op(B[i]) and C[i]. </param>
            <param name="k">number of columns of op(A[i]) and rows of op(B[i]).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">pointer to the A matrix corresponding to the first instance of the batch, with dimensions lda x k with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x m with lda>=max(1,k) otherwise. </param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i]. </param>
            <param name="strideA">Value of type long long int that gives the address offset between A[i] and A[i+1]</param>
            <param name="B">pointer to the B matrix corresponding to the first instance of the batch, with dimensions ldb x n with ldb>=max(1,k) if transa==CUBLAS_OP_N and ldb x k with ldb>=max(1,n) max(1,) otherwise. </param>
            <param name="ldb">leading dimension of two-dimensional array used to store each matrix B[i]. </param>
            <param name="strideB">Value of type long long int that gives the address offset between B[i] and B[i+1]</param>
            <param name="beta"> scalar used for multiplication. If beta == 0, C does not have to be a valid input.</param>
            <param name="C">pointer to the C matrix corresponding to the first instance of the batch, with dimensions ldc x n with ldc>=max(1,m). </param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix C[i]. </param>
            <param name="strideC">Value of type long long int that gives the address offset between C[i] and C[i+1]</param>
            <param name="batchCount">number of GEMMs to perform in the batch.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetrfBatchedS(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            This function performs the LU factorization of an array of n x n matrices.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimension n to 32.
            </summary>
            <param name="n">number of rows and columns of A[i].</param>
            <param name="A">array of device pointers with each array/device pointer of dim. n x n with lda>=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="P">array of size n x batchSize that contains the permutation vector 
            of each factorization of A[i] stored in a linear fashion.</param>
            <param name="INFO">If info=0, the execution is successful.<para/>
            If info = -i, the i-th parameter had an illegal value.<para/>
            If info = i, aii is 0. The factorization has been completed, but U is exactly singular.</param>
            <param name="batchSize">number of pointers contained in A</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetrfBatchedD(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            This function performs the LU factorization of an array of n x n matrices.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimension n to 32.
            </summary>
            <param name="n">number of rows and columns of A[i].</param>
            <param name="A">array of device pointers with each array/device pointer of dim. n x n with lda>=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="P">array of size n x batchSize that contains the permutation vector 
            of each factorization of A[i] stored in a linear fashion.</param>
            <param name="INFO">If info=0, the execution is successful.<para/>
            If info = -i, the i-th parameter had an illegal value.<para/>
            If info = i, aii is 0. The factorization has been completed, but U is exactly singular.</param>
            <param name="batchSize">number of pointers contained in A</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetrfBatchedC(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            This function performs the LU factorization of an array of n x n matrices.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimension n to 32.
            </summary>
            <param name="n">number of rows and columns of A[i].</param>
            <param name="A">array of device pointers with each array/device pointer of dim. n x n with lda>=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="P">array of size n x batchSize that contains the permutation vector 
            of each factorization of A[i] stored in a linear fashion.</param>
            <param name="INFO">If info=0, the execution is successful.<para/>
            If info = -i, the i-th parameter had an illegal value.<para/>
            If info = i, aii is 0. The factorization has been completed, but U is exactly singular.</param>
            <param name="batchSize">number of pointers contained in A</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetrfBatchedZ(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            This function performs the LU factorization of an array of n x n matrices.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimension n to 32.
            </summary>
            <param name="n">number of rows and columns of A[i].</param>
            <param name="A">array of device pointers with each array/device pointer of dim. n x n with lda>=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix A[i].</param>
            <param name="P">array of size n x batchSize that contains the permutation vector 
            of each factorization of A[i] stored in a linear fashion.</param>
            <param name="INFO">If info=0, the execution is successful.<para/>
            If info = -i, the i-th parameter had an illegal value.<para/>
            If info = i, aii is 0. The factorization has been completed, but U is exactly singular.</param>
            <param name="batchSize">number of pointers contained in A</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetriBatchedS(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            Aarray and Carray are arrays of pointers to matrices stored in column-major format
            with dimensions n*n and leading dimension lda and ldc respectively.
            This function performs the inversion of matrices A[i] for i = 0, ..., batchSize-1.<para/>
            Prior to calling GetriBatched, the matrix A[i] must be factorized first using
            the routine GetrfBatched. After the call of GetrfBatched, the matrix
            pointing by Aarray[i] will contain the LU factors of the matrix A[i] and the vector
            pointing by (PivotArray+i) will contain the pivoting sequence.<para/>
            Following the LU factorization, GetriBatched uses forward and backward
            triangular solvers to complete inversion of matrices A[i] for i = 0, ..., batchSize-1. The
            inversion is out-of-place, so memory space of Carray[i] cannot overlap memory space of
            Array[i].
            </summary>
            <param name="n">number of rows and columns of Aarray[i].</param>
            <param name="Aarray">array of pointers to array, with each array of dimension n*n with lda>=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i].</param>
            <param name="P">array of size n*batchSize that contains the pivoting sequence of each factorization of Aarray[i] stored in a linear fashion.</param>
            <param name="Carray">array of pointers to array, with each array of dimension n*n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix Carray[i].</param>
            <param name="INFO">array of size batchSize that info(=infoArray[i]) contains the information of inversion of A[i].<para/>
            If info=0, the execution is successful.<para/>
            If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed.</param>
            <param name="batchSize">number of pointers contained in A</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetriBatchedD(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            Aarray and Carray are arrays of pointers to matrices stored in column-major format
            with dimensions n*n and leading dimension lda and ldc respectively.
            This function performs the inversion of matrices A[i] for i = 0, ..., batchSize-1.<para/>
            Prior to calling GetriBatched, the matrix A[i] must be factorized first using
            the routine GetrfBatched. After the call of GetrfBatched, the matrix
            pointing by Aarray[i] will contain the LU factors of the matrix A[i] and the vector
            pointing by (PivotArray+i) will contain the pivoting sequence.<para/>
            Following the LU factorization, GetriBatched uses forward and backward
            triangular solvers to complete inversion of matrices A[i] for i = 0, ..., batchSize-1. The
            inversion is out-of-place, so memory space of Carray[i] cannot overlap memory space of
            Array[i].
            </summary>
            <param name="n">number of rows and columns of Aarray[i].</param>
            <param name="Aarray">array of pointers to array, with each array of dimension n*n with lda>=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i].</param>
            <param name="P">array of size n*batchSize that contains the pivoting sequence of each factorization of Aarray[i] stored in a linear fashion.</param>
            <param name="Carray">array of pointers to array, with each array of dimension n*n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix Carray[i].</param>
            <param name="INFO">array of size batchSize that info(=infoArray[i]) contains the information of inversion of A[i].<para/>
            If info=0, the execution is successful.<para/>
            If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed.</param>
            <param name="batchSize">number of pointers contained in A</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetriBatchedC(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            Aarray and Carray are arrays of pointers to matrices stored in column-major format
            with dimensions n*n and leading dimension lda and ldc respectively.
            This function performs the inversion of matrices A[i] for i = 0, ..., batchSize-1.<para/>
            Prior to calling GetriBatched, the matrix A[i] must be factorized first using
            the routine GetrfBatched. After the call of GetrfBatched, the matrix
            pointing by Aarray[i] will contain the LU factors of the matrix A[i] and the vector
            pointing by (PivotArray+i) will contain the pivoting sequence.<para/>
            Following the LU factorization, GetriBatched uses forward and backward
            triangular solvers to complete inversion of matrices A[i] for i = 0, ..., batchSize-1. The
            inversion is out-of-place, so memory space of Carray[i] cannot overlap memory space of
            Array[i].
            </summary>
            <param name="n">number of rows and columns of Aarray[i].</param>
            <param name="Aarray">array of pointers to array, with each array of dimension n*n with lda>=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i].</param>
            <param name="P">array of size n*batchSize that contains the pivoting sequence of each factorization of Aarray[i] stored in a linear fashion.</param>
            <param name="Carray">array of pointers to array, with each array of dimension n*n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix Carray[i].</param>
            <param name="INFO">array of size batchSize that info(=infoArray[i]) contains the information of inversion of A[i].<para/>
            If info=0, the execution is successful.<para/>
            If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed.</param>
            <param name="batchSize">number of pointers contained in A</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetriBatchedZ(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32)">
            <summary>
            Aarray and Carray are arrays of pointers to matrices stored in column-major format
            with dimensions n*n and leading dimension lda and ldc respectively.
            This function performs the inversion of matrices A[i] for i = 0, ..., batchSize-1.<para/>
            Prior to calling GetriBatched, the matrix A[i] must be factorized first using
            the routine GetrfBatched. After the call of GetrfBatched, the matrix
            pointing by Aarray[i] will contain the LU factors of the matrix A[i] and the vector
            pointing by (PivotArray+i) will contain the pivoting sequence.<para/>
            Following the LU factorization, GetriBatched uses forward and backward
            triangular solvers to complete inversion of matrices A[i] for i = 0, ..., batchSize-1. The
            inversion is out-of-place, so memory space of Carray[i] cannot overlap memory space of
            Array[i].
            </summary>
            <param name="n">number of rows and columns of Aarray[i].</param>
            <param name="Aarray">array of pointers to array, with each array of dimension n*n with lda>=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i].</param>
            <param name="P">array of size n*batchSize that contains the pivoting sequence of each factorization of Aarray[i] stored in a linear fashion.</param>
            <param name="Carray">array of pointers to array, with each array of dimension n*n with ldc>=max(1,n).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix Carray[i].</param>
            <param name="INFO">array of size batchSize that info(=infoArray[i]) contains the information of inversion of A[i].<para/>
            If info=0, the execution is successful.<para/>
            If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed.</param>
            <param name="batchSize">number of pointers contained in A</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.TrsmBatched(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of triangular linear systems with multiple right-hand-sides.<para/>
            The solution overwrites the right-hand-sides on exit.<para/>
            No test for singularity or near-singularity is included in this function.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimensions m and n to 32.
            </summary>
            <param name="side">indicates if matrix A[i] is on the left or right of X[i].</param>
            <param name="uplo">indicates if matrix A[i] lower or upper part is stored, the
            other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix
            A[i] are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B[i], with matrix A[i] sized accordingly.</param>
            <param name="n">number of columns of matrix B[i], with matrix A[i] is sized accordingly.</param>
            <param name="alpha">scalar used for multiplication, if alpha==0 then A[i] is not 
            referenced and B[i] does not have to be a valid input.</param>
            <param name="A">array of device pointers with each array/device pointerarray 
            of dim. lda x m with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x n with
            lda>=max(1,n) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A[i].</param>
            <param name="B">array of device pointers with each array/device pointerarrayof dim.
            ldb x n with ldb>=max(1,m)</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B[i].</param>
            <param name="batchCount"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.TrsmBatched(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of triangular linear systems with multiple right-hand-sides.<para/>
            The solution overwrites the right-hand-sides on exit.<para/>
            No test for singularity or near-singularity is included in this function.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimensions m and n to 32.
            </summary>
            <param name="side">indicates if matrix A[i] is on the left or right of X[i].</param>
            <param name="uplo">indicates if matrix A[i] lower or upper part is stored, the
            other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix
            A[i] are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B[i], with matrix A[i] sized accordingly.</param>
            <param name="n">number of columns of matrix B[i], with matrix A[i] is sized accordingly.</param>
            <param name="alpha">scalar used for multiplication, if alpha==0 then A[i] is not 
            referenced and B[i] does not have to be a valid input.</param>
            <param name="A">array of device pointers with each array/device pointerarray 
            of dim. lda x m with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x n with
            lda>=max(1,n) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A[i].</param>
            <param name="B">array of device pointers with each array/device pointerarrayof dim.
            ldb x n with ldb>=max(1,m)</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B[i].</param>
            <param name="batchCount"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.TrsmBatched(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of triangular linear systems with multiple right-hand-sides.<para/>
            The solution overwrites the right-hand-sides on exit.<para/>
            No test for singularity or near-singularity is included in this function.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimensions m and n to 32.
            </summary>
            <param name="side">indicates if matrix A[i] is on the left or right of X[i].</param>
            <param name="uplo">indicates if matrix A[i] lower or upper part is stored, the
            other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix
            A[i] are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B[i], with matrix A[i] sized accordingly.</param>
            <param name="n">number of columns of matrix B[i], with matrix A[i] is sized accordingly.</param>
            <param name="alpha">scalar used for multiplication, if alpha==0 then A[i] is not 
            referenced and B[i] does not have to be a valid input.</param>
            <param name="A">array of device pointers with each array/device pointerarray 
            of dim. lda x m with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x n with
            lda>=max(1,n) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A[i].</param>
            <param name="B">array of device pointers with each array/device pointerarrayof dim.
            ldb x n with ldb>=max(1,m)</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B[i].</param>
            <param name="batchCount"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.TrsmBatched(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of triangular linear systems with multiple right-hand-sides.<para/>
            The solution overwrites the right-hand-sides on exit.<para/>
            No test for singularity or near-singularity is included in this function.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimensions m and n to 32.
            </summary>
            <param name="side">indicates if matrix A[i] is on the left or right of X[i].</param>
            <param name="uplo">indicates if matrix A[i] lower or upper part is stored, the
            other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix
            A[i] are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B[i], with matrix A[i] sized accordingly.</param>
            <param name="n">number of columns of matrix B[i], with matrix A[i] is sized accordingly.</param>
            <param name="alpha">scalar used for multiplication, if alpha==0 then A[i] is not 
            referenced and B[i] does not have to be a valid input.</param>
            <param name="A">array of device pointers with each array/device pointerarray 
            of dim. lda x m with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x n with
            lda>=max(1,n) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A[i].</param>
            <param name="B">array of device pointers with each array/device pointerarrayof dim.
            ldb x n with ldb>=max(1,m)</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B[i].</param>
            <param name="batchCount"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.TrsmBatched(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of triangular linear systems with multiple right-hand-sides.<para/>
            The solution overwrites the right-hand-sides on exit.<para/>
            No test for singularity or near-singularity is included in this function.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimensions m and n to 32.
            </summary>
            <param name="side">indicates if matrix A[i] is on the left or right of X[i].</param>
            <param name="uplo">indicates if matrix A[i] lower or upper part is stored, the
            other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix
            A[i] are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B[i], with matrix A[i] sized accordingly.</param>
            <param name="n">number of columns of matrix B[i], with matrix A[i] is sized accordingly.</param>
            <param name="alpha">scalar used for multiplication, if alpha==0 then A[i] is not 
            referenced and B[i] does not have to be a valid input.</param>
            <param name="A">array of device pointers with each array/device pointerarray 
            of dim. lda x m with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x n with
            lda>=max(1,n) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A[i].</param>
            <param name="B">array of device pointers with each array/device pointerarrayof dim.
            ldb x n with ldb>=max(1,m)</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B[i].</param>
            <param name="batchCount"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.TrsmBatched(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of triangular linear systems with multiple right-hand-sides.<para/>
            The solution overwrites the right-hand-sides on exit.<para/>
            No test for singularity or near-singularity is included in this function.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimensions m and n to 32.
            </summary>
            <param name="side">indicates if matrix A[i] is on the left or right of X[i].</param>
            <param name="uplo">indicates if matrix A[i] lower or upper part is stored, the
            other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix
            A[i] are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B[i], with matrix A[i] sized accordingly.</param>
            <param name="n">number of columns of matrix B[i], with matrix A[i] is sized accordingly.</param>
            <param name="alpha">scalar used for multiplication, if alpha==0 then A[i] is not 
            referenced and B[i] does not have to be a valid input.</param>
            <param name="A">array of device pointers with each array/device pointerarray 
            of dim. lda x m with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x n with
            lda>=max(1,n) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A[i].</param>
            <param name="B">array of device pointers with each array/device pointerarrayof dim.
            ldb x n with ldb>=max(1,m)</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B[i].</param>
            <param name="batchCount"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.TrsmBatched(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of triangular linear systems with multiple right-hand-sides.<para/>
            The solution overwrites the right-hand-sides on exit.<para/>
            No test for singularity or near-singularity is included in this function.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimensions m and n to 32.
            </summary>
            <param name="side">indicates if matrix A[i] is on the left or right of X[i].</param>
            <param name="uplo">indicates if matrix A[i] lower or upper part is stored, the
            other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix
            A[i] are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B[i], with matrix A[i] sized accordingly.</param>
            <param name="n">number of columns of matrix B[i], with matrix A[i] is sized accordingly.</param>
            <param name="alpha">scalar used for multiplication, if alpha==0 then A[i] is not 
            referenced and B[i] does not have to be a valid input.</param>
            <param name="A">array of device pointers with each array/device pointerarray 
            of dim. lda x m with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x n with
            lda>=max(1,n) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A[i].</param>
            <param name="B">array of device pointers with each array/device pointerarrayof dim.
            ldb x n with ldb>=max(1,m)</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B[i].</param>
            <param name="batchCount"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.TrsmBatched(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,ManagedCuda.CudaBlas.DiagType,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of triangular linear systems with multiple right-hand-sides.<para/>
            The solution overwrites the right-hand-sides on exit.<para/>
            No test for singularity or near-singularity is included in this function.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor. The current implementation limits the dimensions m and n to 32.
            </summary>
            <param name="side">indicates if matrix A[i] is on the left or right of X[i].</param>
            <param name="uplo">indicates if matrix A[i] lower or upper part is stored, the
            other part is not referenced and is inferred from the stored elements.</param>
            <param name="trans">operation op(A[i]) that is non- or (conj.) transpose.</param>
            <param name="diag">indicates if the elements on the main diagonal of matrix
            A[i] are unity and should not be accessed.</param>
            <param name="m">number of rows of matrix B[i], with matrix A[i] sized accordingly.</param>
            <param name="n">number of columns of matrix B[i], with matrix A[i] is sized accordingly.</param>
            <param name="alpha">scalar used for multiplication, if alpha==0 then A[i] is not 
            referenced and B[i] does not have to be a valid input.</param>
            <param name="A">array of device pointers with each array/device pointerarray 
            of dim. lda x m with lda>=max(1,m) if transa==CUBLAS_OP_N and lda x n with
            lda>=max(1,n) otherwise.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A[i].</param>
            <param name="B">array of device pointers with each array/device pointerarrayof dim.
            ldb x n with ldb>=max(1,m)</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B[i].</param>
            <param name="batchCount"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Stpttr(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs the conversion from the triangular packed format to the
            triangular format.<para/>
            If uplo == CUBLAS_FILL_MODE_LOWER then the elements of AP are copied into the
            lower triangular part of the triangular matrix A and the upper part of A is left untouched.<para/>
            If uplo == CUBLAS_FILL_MODE_UPPER then the elements of AP are copied into the
            upper triangular part of the triangular matrix A and the lower part of A is left untouched.
            </summary>
            <param name="uplo">indicates if matrix AP contains lower or upper part of matrix A.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="AP">array with A stored in packed format.</param>
            <param name="A">array of dimensions lda x n , with lda&gt;=max(1,n). The
            opposite side of A is left untouched.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dtpttr(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs the conversion from the triangular packed format to the
            triangular format.<para/>
            If uplo == CUBLAS_FILL_MODE_LOWER then the elements of AP are copied into the
            lower triangular part of the triangular matrix A and the upper part of A is left untouched.<para/>
            If uplo == CUBLAS_FILL_MODE_UPPER then the elements of AP are copied into the
            upper triangular part of the triangular matrix A and the lower part of A is left untouched.
            </summary>
            <param name="uplo">indicates if matrix AP contains lower or upper part of matrix A.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="AP">array with A stored in packed format.</param>
            <param name="A">array of dimensions lda x n , with lda&gt;=max(1,n). The
            opposite side of A is left untouched.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Ctpttr(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs the conversion from the triangular packed format to the
            triangular format.<para/>
            If uplo == CUBLAS_FILL_MODE_LOWER then the elements of AP are copied into the
            lower triangular part of the triangular matrix A and the upper part of A is left untouched.<para/>
            If uplo == CUBLAS_FILL_MODE_UPPER then the elements of AP are copied into the
            upper triangular part of the triangular matrix A and the lower part of A is left untouched.
            </summary>
            <param name="uplo">indicates if matrix AP contains lower or upper part of matrix A.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="AP">array with A stored in packed format.</param>
            <param name="A">array of dimensions lda x n , with lda&gt;=max(1,n). The
            opposite side of A is left untouched.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Ztpttr(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs the conversion from the triangular packed format to the
            triangular format.<para/>
            If uplo == CUBLAS_FILL_MODE_LOWER then the elements of AP are copied into the
            lower triangular part of the triangular matrix A and the upper part of A is left untouched.<para/>
            If uplo == CUBLAS_FILL_MODE_UPPER then the elements of AP are copied into the
            upper triangular part of the triangular matrix A and the lower part of A is left untouched.
            </summary>
            <param name="uplo">indicates if matrix AP contains lower or upper part of matrix A.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="AP">array with A stored in packed format.</param>
            <param name="A">array of dimensions lda x n , with lda&gt;=max(1,n). The
            opposite side of A is left untouched.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Strttp(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the conversion from the triangular format to the triangular
            packed format.<para/>
            If uplo == CUBLAS_FILL_MODE_LOWER then the lower triangular part of the triangular
            matrix A is copied into the array AP. <para/>If uplo == CUBLAS_FILL_MODE_UPPER then then
            the upper triangular part of the triangular matrix A is copied into the array AP
            </summary>
            <param name="uplo">indicates which matrix A lower or upper part is referenced</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimensions lda x n , with lda&gt;=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Dtrttp(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the conversion from the triangular format to the triangular
            packed format.<para/>
            If uplo == CUBLAS_FILL_MODE_LOWER then the lower triangular part of the triangular
            matrix A is copied into the array AP. <para/>If uplo == CUBLAS_FILL_MODE_UPPER then then
            the upper triangular part of the triangular matrix A is copied into the array AP
            </summary>
            <param name="uplo">indicates which matrix A lower or upper part is referenced</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimensions lda x n , with lda&gt;=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Ctrttp(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the conversion from the triangular format to the triangular
            packed format.<para/>
            If uplo == CUBLAS_FILL_MODE_LOWER then the lower triangular part of the triangular
            matrix A is copied into the array AP. <para/>If uplo == CUBLAS_FILL_MODE_UPPER then then
            the upper triangular part of the triangular matrix A is copied into the array AP
            </summary>
            <param name="uplo">indicates which matrix A lower or upper part is referenced</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimensions lda x n , with lda&gt;=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.Ztrttp(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the conversion from the triangular format to the triangular
            packed format.<para/>
            If uplo == CUBLAS_FILL_MODE_LOWER then the lower triangular part of the triangular
            matrix A is copied into the array AP. <para/>If uplo == CUBLAS_FILL_MODE_UPPER then then
            the upper triangular part of the triangular matrix A is copied into the array AP
            </summary>
            <param name="uplo">indicates which matrix A lower or upper part is referenced</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimensions lda x n , with lda&gt;=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="AP">array with A stored in packed format.</param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GeqrfBatchedS(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr})">
            <summary>
            This function performs the QR factorization of each Aarray[i] for i =
            0, ...,batchSize-1 using Householder reflections. Each matrix Q[i] is represented
            as a product of elementary reflectors and is stored in the lower part of each Aarray[i].
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.<para/>
            cublas<![CDATA[<t>]]>geqrfBatched supports arbitrary dimension.<para/>
            cublas<![CDATA[<t>]]>geqrfBatched only supports compute capability 2.0 or above.
            </summary>
            <param name="m">number of rows Aarray[i].</param>
            <param name="n">number of columns of Aarray[i].</param>
            <param name="Aarray">array of pointers to device array, with each array of dim. m x n with lda&gt;=max(1,m). The array size determines the number of batches.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i].</param>
            <param name="TauArray">array of pointers to device vector, with each vector of dim. max(1,min(m,n)).</param>
            <returns>0, if the parameters passed to the function are valid, &lt;0, if the parameter in postion -value is invalid</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GeqrfBatchedD(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr})">
            <summary>
            This function performs the QR factorization of each Aarray[i] for i =
            0, ...,batchSize-1 using Householder reflections. Each matrix Q[i] is represented
            as a product of elementary reflectors and is stored in the lower part of each Aarray[i].
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.<para/>
            cublas<![CDATA[<t>]]>geqrfBatched supports arbitrary dimension.<para/>
            cublas<![CDATA[<t>]]>geqrfBatched only supports compute capability 2.0 or above.
            </summary>
            <param name="m">number of rows Aarray[i].</param>
            <param name="n">number of columns of Aarray[i].</param>
            <param name="Aarray">array of pointers to device array, with each array of dim. m x n with lda&gt;=max(1,m). The array size determines the number of batches.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i].</param>
            <param name="TauArray">array of pointers to device vector, with each vector of dim. max(1,min(m,n)).</param>
            <returns>0, if the parameters passed to the function are valid, &lt;0, if the parameter in postion -value is invalid</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GeqrfBatchedC(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr})">
            <summary>
            This function performs the QR factorization of each Aarray[i] for i =
            0, ...,batchSize-1 using Householder reflections. Each matrix Q[i] is represented
            as a product of elementary reflectors and is stored in the lower part of each Aarray[i].
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.<para/>
            cublas<![CDATA[<t>]]>geqrfBatched supports arbitrary dimension.<para/>
            cublas<![CDATA[<t>]]>geqrfBatched only supports compute capability 2.0 or above.
            </summary>
            <param name="m">number of rows Aarray[i].</param>
            <param name="n">number of columns of Aarray[i].</param>
            <param name="Aarray">array of pointers to device array, with each array of dim. m x n with lda&gt;=max(1,m). The array size determines the number of batches.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i].</param>
            <param name="TauArray">array of pointers to device vector, with each vector of dim. max(1,min(m,n)).</param>
            <returns>0, if the parameters passed to the function are valid, &lt;0, if the parameter in postion -value is invalid</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GeqrfBatchedZ(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr})">
            <summary>
            This function performs the QR factorization of each Aarray[i] for i =
            0, ...,batchSize-1 using Householder reflections. Each matrix Q[i] is represented
            as a product of elementary reflectors and is stored in the lower part of each Aarray[i].
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.<para/>
            cublas<![CDATA[<t>]]>geqrfBatched supports arbitrary dimension.<para/>
            cublas<![CDATA[<t>]]>geqrfBatched only supports compute capability 2.0 or above.
            </summary>
            <param name="m">number of rows Aarray[i].</param>
            <param name="n">number of columns of Aarray[i].</param>
            <param name="Aarray">array of pointers to device array, with each array of dim. m x n with lda&gt;=max(1,m). The array size determines the number of batches.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i].</param>
            <param name="TauArray">array of pointers to device vector, with each vector of dim. max(1,min(m,n)).</param>
            <returns>0, if the parameters passed to the function are valid, &lt;0, if the parameter in postion -value is invalid</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GelsBatchedS(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function find the least squares solution of a batch of overdetermined systems.
            On exit, each Aarray[i] is overwritten with their QR factorization and each Carray[i] is overwritten with the least square solution
            GelsBatched supports only the non-transpose operation and only solves overdetermined
            systems (m >= n).<para/>
            GelsBatched only supports compute capability 2.0 or above.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.
            </summary>
            <param name="trans">operation op(Aarray[i]) that is non- or (conj.) transpose. Only non-transpose operation is currently supported.</param>
            <param name="m">number of rows Aarray[i].</param>
            <param name="n">number of columns of each Aarray[i] and rows of each Carray[i].</param>
            <param name="nrhs">number of columns of each Carray[i].</param>
            <param name="Aarray">array of pointers to device array, with each array of dim. m x n with lda&gt;=max(1,m). The array size determines the number of batches.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i]</param>
            <param name="Carray">array of pointers to device array, with each array of dim. m x n with ldc&gt;=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix Carray[i].</param>
            <param name="devInfoArray">null or optional array of integers of dimension batchsize.</param>
            <returns>0, if the parameters passed to the function are valid, &lt;0, if the parameter in postion -value is invalid</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GelsBatchedD(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function find the least squares solution of a batch of overdetermined systems.
            On exit, each Aarray[i] is overwritten with their QR factorization and each Carray[i] is overwritten with the least square solution
            GelsBatched supports only the non-transpose operation and only solves overdetermined
            systems (m >= n).<para/>
            GelsBatched only supports compute capability 2.0 or above.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.
            </summary>
            <param name="trans">operation op(Aarray[i]) that is non- or (conj.) transpose. Only non-transpose operation is currently supported.</param>
            <param name="m">number of rows Aarray[i].</param>
            <param name="n">number of columns of each Aarray[i] and rows of each Carray[i].</param>
            <param name="nrhs">number of columns of each Carray[i].</param>
            <param name="Aarray">array of pointers to device array, with each array of dim. m x n with lda&gt;=max(1,m). The array size determines the number of batches.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i]</param>
            <param name="Carray">array of pointers to device array, with each array of dim. m x n with ldc&gt;=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix Carray[i].</param>
            <param name="devInfoArray">null or optional array of integers of dimension batchsize.</param>
            <returns>0, if the parameters passed to the function are valid, &lt;0, if the parameter in postion -value is invalid</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GelsBatchedC(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function find the least squares solution of a batch of overdetermined systems.
            On exit, each Aarray[i] is overwritten with their QR factorization and each Carray[i] is overwritten with the least square solution
            GelsBatched supports only the non-transpose operation and only solves overdetermined
            systems (m >= n).<para/>
            GelsBatched only supports compute capability 2.0 or above.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.
            </summary>
            <param name="trans">operation op(Aarray[i]) that is non- or (conj.) transpose. Only non-transpose operation is currently supported.</param>
            <param name="m">number of rows Aarray[i].</param>
            <param name="n">number of columns of each Aarray[i] and rows of each Carray[i].</param>
            <param name="nrhs">number of columns of each Carray[i].</param>
            <param name="Aarray">array of pointers to device array, with each array of dim. m x n with lda&gt;=max(1,m). The array size determines the number of batches.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i]</param>
            <param name="Carray">array of pointers to device array, with each array of dim. m x n with ldc&gt;=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix Carray[i].</param>
            <param name="devInfoArray">null or optional array of integers of dimension batchsize.</param>
            <returns>0, if the parameters passed to the function are valid, &lt;0, if the parameter in postion -value is invalid</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GelsBatchedZ(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function find the least squares solution of a batch of overdetermined systems.
            On exit, each Aarray[i] is overwritten with their QR factorization and each Carray[i] is overwritten with the least square solution
            GelsBatched supports only the non-transpose operation and only solves overdetermined
            systems (m >= n).<para/>
            GelsBatched only supports compute capability 2.0 or above.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.
            </summary>
            <param name="trans">operation op(Aarray[i]) that is non- or (conj.) transpose. Only non-transpose operation is currently supported.</param>
            <param name="m">number of rows Aarray[i].</param>
            <param name="n">number of columns of each Aarray[i] and rows of each Carray[i].</param>
            <param name="nrhs">number of columns of each Carray[i].</param>
            <param name="Aarray">array of pointers to device array, with each array of dim. m x n with lda&gt;=max(1,m). The array size determines the number of batches.</param>
            <param name="lda">leading dimension of two-dimensional array used to store each matrix Aarray[i]</param>
            <param name="Carray">array of pointers to device array, with each array of dim. m x n with ldc&gt;=max(1,m).</param>
            <param name="ldc">leading dimension of two-dimensional array used to store each matrix Carray[i].</param>
            <param name="devInfoArray">null or optional array of integers of dimension batchsize.</param>
            <returns>0, if the parameters passed to the function are valid, &lt;0, if the parameter in postion -value is invalid</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetrsBatchedS(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of systems of linear equations of the form:<para/>
            op(A[i]) X[i] = a B[i]<para/>
            where A[i] is a matrix which has been LU factorized with pivoting, X[i] and B[i] are
            n x nrhs matrices.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of Aarray[i].</param>
            <param name="nrhs">number of columns of Barray[i].</param>
            <param name="Aarray">array of pointers to array, with each array of dim. n 
            x n with lda&gt;=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store
            each matrix Aarray[i].</param>
            <param name="devIpiv">array of size n x batchSize that contains the pivoting
            sequence of each factorization of Aarray[i] stored in a
            linear fashion. If devIpiv is nil, pivoting for all Aarray[i]
            is ignored.</param>
            <param name="Barray">array of pointers to array, with each array of dim. n
            x nrhs with ldb&gt;=max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store
            each solution matrix Barray[i].</param>
            <param name="batchSize">number of pointers contained in A</param>
            <returns>If info=0, the execution is successful. If info = -j, the j-th parameter had an illegal value.</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetrsBatchedD(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of systems of linear equations of the form:<para/>
            op(A[i]) X[i] = a B[i]<para/>
            where A[i] is a matrix which has been LU factorized with pivoting, X[i] and B[i] are
            n x nrhs matrices.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of Aarray[i].</param>
            <param name="nrhs">number of columns of Barray[i].</param>
            <param name="Aarray">array of pointers to array, with each array of dim. n 
            x n with lda&gt;=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store
            each matrix Aarray[i].</param>
            <param name="devIpiv">array of size n x batchSize that contains the pivoting
            sequence of each factorization of Aarray[i] stored in a
            linear fashion. If devIpiv is nil, pivoting for all Aarray[i]
            is ignored.</param>
            <param name="Barray">array of pointers to array, with each array of dim. n
            x nrhs with ldb&gt;=max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store
            each solution matrix Barray[i].</param>
            <param name="batchSize">number of pointers contained in A</param>
            <returns>If info=0, the execution is successful. If info = -j, the j-th parameter had an illegal value.</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetrsBatchedC(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of systems of linear equations of the form:<para/>
            op(A[i]) X[i] = a B[i]<para/>
            where A[i] is a matrix which has been LU factorized with pivoting, X[i] and B[i] are
            n x nrhs matrices.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of Aarray[i].</param>
            <param name="nrhs">number of columns of Barray[i].</param>
            <param name="Aarray">array of pointers to array, with each array of dim. n 
            x n with lda&gt;=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store
            each matrix Aarray[i].</param>
            <param name="devIpiv">array of size n x batchSize that contains the pivoting
            sequence of each factorization of Aarray[i] stored in a
            linear fashion. If devIpiv is nil, pivoting for all Aarray[i]
            is ignored.</param>
            <param name="Barray">array of pointers to array, with each array of dim. n
            x nrhs with ldb&gt;=max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store
            each solution matrix Barray[i].</param>
            <param name="batchSize">number of pointers contained in A</param>
            <returns>If info=0, the execution is successful. If info = -j, the j-th parameter had an illegal value.</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetrsBatchedZ(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32)">
            <summary>
            This function solves an array of systems of linear equations of the form:<para/>
            op(A[i]) X[i] = a B[i]<para/>
            where A[i] is a matrix which has been LU factorized with pivoting, X[i] and B[i] are
            n x nrhs matrices.<para/>
            This function is intended to be used for matrices of small sizes where the launch
            overhead is a significant factor.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of Aarray[i].</param>
            <param name="nrhs">number of columns of Barray[i].</param>
            <param name="Aarray">array of pointers to array, with each array of dim. n 
            x n with lda&gt;=max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store
            each matrix Aarray[i].</param>
            <param name="devIpiv">array of size n x batchSize that contains the pivoting
            sequence of each factorization of Aarray[i] stored in a
            linear fashion. If devIpiv is nil, pivoting for all Aarray[i]
            is ignored.</param>
            <param name="Barray">array of pointers to array, with each array of dim. n
            x nrhs with ldb&gt;=max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store
            each solution matrix Barray[i].</param>
            <param name="batchSize">number of pointers contained in A</param>
            <returns>If info=0, the execution is successful. If info = -j, the j-th parameter had an illegal value.</returns>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.SetVector``1(``0[],System.Int32,ManagedCuda.CudaDeviceVariable{``0},System.Int32)">
            <summary>
            copies elements from a vector <c>hostSourceVector</c> in CPU memory space to a vector <c>devDestVector</c> 
            in GPU memory space. Storage spacing between consecutive elements
            is <c>incrHostSource</c> for the source vector <c>hostSourceVector</c> and <c>incrDevDest</c> for the destination vector
            <c>devDestVector</c>. Column major format for two-dimensional matrices
            is assumed throughout CUBLAS. Therefore, if the increment for a vector 
            is equal to 1, this access a column vector while using an increment 
            equal to the leading dimension of the respective matrix accesses a 
            row vector.
            </summary>
            <typeparam name="T">Vector datatype </typeparam>
            <param name="hostSourceVector">Source vector in host memory</param>
            <param name="incrHostSource"></param>
            <param name="devDestVector">Destination vector in device memory</param>
            <param name="incrDevDest"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetVector``1(ManagedCuda.CudaDeviceVariable{``0},System.Int32,``0[],System.Int32)">
            <summary>
            copies elements from a vector <c>devSourceVector</c> in GPU memory space to a vector <c>hostDestVector</c> 
            in CPU memory space. Storage spacing between consecutive elements
            is <c>incrHostDest</c> for the source vector <c>devSourceVector</c> and <c>incrDevSource</c> for the destination vector
            <c>hostDestVector</c>. Column major format for two-dimensional matrices
            is assumed throughout CUBLAS. Therefore, if the increment for a vector 
            is equal to 1, this access a column vector while using an increment 
            equal to the leading dimension of the respective matrix accesses a 
            row vector.
            </summary>
            <typeparam name="T">Vector datatype</typeparam>
            <param name="devSourceVector">Source vector in device memory</param>
            <param name="incrDevSource"></param>
            <param name="hostDestVector">Destination vector in host memory</param>
            <param name="incrHostDest"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.SetMatrix``1(System.Int32,System.Int32,``0[],System.Int32,ManagedCuda.CudaDeviceVariable{``0},System.Int32)">
            <summary>
            copies a tile of <c>rows</c> x <c>cols</c> elements from a matrix <c>hostSource</c> in CPU memory
            space to a matrix <c>devDest</c> in GPU memory space. Both matrices are assumed to be stored in column 
            major format, with the leading dimension (i.e. number of rows) of 
            source matrix <c>hostSource</c> provided in <c>ldHostSource</c>, and the leading dimension of matrix <c>devDest</c>
            provided in <c>ldDevDest</c>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="rows"></param>
            <param name="cols"></param>
            <param name="hostSource"></param>
            <param name="ldHostSource"></param>
            <param name="devDest"></param>
            <param name="ldDevDest"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetMatrix``1(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{``0},System.Int32,``0[],System.Int32)">
            <summary>
            copies a tile of <c>rows</c> x <c>cols</c> elements from a matrix <c>devSource</c> in GPU memory
            space to a matrix <c>hostDest</c> in CPU memory space. Both matrices are assumed to be stored in column 
            major format, with the leading dimension (i.e. number of rows) of 
            source matrix <c>devSource</c> provided in <c>devSource</c>, and the leading dimension of matrix <c>hostDest</c>
            provided in <c>ldHostDest</c>. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="rows"></param>
            <param name="cols"></param>
            <param name="devSource"></param>
            <param name="ldDevSource"></param>
            <param name="hostDest"></param>
            <param name="ldHostDest"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.SetVectorAsync``1(``0[],System.Int32,ManagedCuda.CudaDeviceVariable{``0},System.Int32,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            copies elements from a vector <c>hostSourceVector</c> in CPU memory space to a vector <c>devDestVector</c> 
            in GPU memory space. Storage spacing between consecutive elements
            is <c>incrHostSource</c> for the source vector <c>hostSourceVector</c> and <c>incrDevDest</c> for the destination vector
            <c>devDestVector</c>. Column major format for two-dimensional matrices
            is assumed throughout CUBLAS. Therefore, if the increment for a vector 
            is equal to 1, this access a column vector while using an increment 
            equal to the leading dimension of the respective matrix accesses a 
            row vector.
            </summary>
            <typeparam name="T">Vector datatype </typeparam>
            <param name="hostSourceVector">Source vector in host memory</param>
            <param name="incrHostSource"></param>
            <param name="devDestVector">Destination vector in device memory</param>
            <param name="incrDevDest"></param>
            <param name="stream"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetVectorAsync``1(ManagedCuda.CudaDeviceVariable{``0},System.Int32,``0[],System.Int32,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            copies elements from a vector <c>devSourceVector</c> in GPU memory space to a vector <c>hostDestVector</c> 
            in CPU memory space. Storage spacing between consecutive elements
            is <c>incrHostDest</c> for the source vector <c>devSourceVector</c> and <c>incrDevSource</c> for the destination vector
            <c>hostDestVector</c>. Column major format for two-dimensional matrices
            is assumed throughout CUBLAS. Therefore, if the increment for a vector 
            is equal to 1, this access a column vector while using an increment 
            equal to the leading dimension of the respective matrix accesses a 
            row vector.
            </summary>
            <typeparam name="T">Vector datatype</typeparam>
            <param name="devSourceVector">Source vector in device memory</param>
            <param name="incrDevSource"></param>
            <param name="hostDestVector">Destination vector in host memory</param>
            <param name="incrHostDest"></param>
            <param name="stream"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.SetMatrixAsync``1(System.Int32,System.Int32,``0[],System.Int32,ManagedCuda.CudaDeviceVariable{``0},System.Int32,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            copies a tile of <c>rows</c> x <c>cols</c> elements from a matrix <c>hostSource</c> in CPU memory
            space to a matrix <c>devDest</c> in GPU memory space. Both matrices are assumed to be stored in column 
            major format, with the leading dimension (i.e. number of rows) of 
            source matrix <c>hostSource</c> provided in <c>ldHostSource</c>, and the leading dimension of matrix <c>devDest</c>
            provided in <c>ldDevDest</c>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="rows"></param>
            <param name="cols"></param>
            <param name="hostSource"></param>
            <param name="ldHostSource"></param>
            <param name="devDest"></param>
            <param name="ldDevDest"></param>
            <param name="stream"></param>
        </member>
        <member name="M:ManagedCuda.CudaBlas.CudaBlas.GetMatrixAsync``1(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{``0},System.Int32,``0[],System.Int32,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            copies a tile of <c>rows</c> x <c>cols</c> elements from a matrix <c>devSource</c> in GPU memory
            space to a matrix <c>hostDest</c> in CPU memory space. Both matrices are assumed to be stored in column 
            major format, with the leading dimension (i.e. number of rows) of 
            source matrix <c>devSource</c> provided in <c>devSource</c>, and the leading dimension of matrix <c>hostDest</c>
            provided in <c>ldHostDest</c>. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="rows"></param>
            <param name="cols"></param>
            <param name="devSource"></param>
            <param name="ldDevSource"></param>
            <param name="hostDest"></param>
            <param name="ldHostDest"></param>
            <param name="stream"></param>
        </member>
        <member name="T:ManagedCuda.CudaBlas.CublasStatus">
            <summary>
            CUBLAS status type returns
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.Success">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.NotInitialized">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.AllocFailed">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.InvalidValue">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.ArchMismatch">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.MappingError">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.ExecutionFailed">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.InternalError">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.NotSupported">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CublasStatus.LicenseError">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.FillMode">
            <summary>
            The FillMode type indicates which part (lower or upper) of the dense matrix was
            filled and consequently should be used by the function. Its values correspond to Fortran
            characters ‘L’ or ‘l’ (lower) and ‘U’ or ‘u’ (upper) that are often used as parameters to
            legacy BLAS implementations.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.FillMode.Lower">
            <summary>
            the lower part of the matrix is filled
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.FillMode.Upper">
            <summary>
            the upper part of the matrix is filled
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.FillMode.Full">
            <summary>
            Full
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.DiagType">
            <summary>
            The DiagType type indicates whether the main diagonal of the dense matrix is
            unity and consequently should not be touched or modified by the function. Its values
            correspond to Fortran characters ‘N’ or ‘n’ (non-unit) and ‘U’ or ‘u’ (unit) that are
            often used as parameters to legacy BLAS implementations.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DiagType.NonUnit">
            <summary>
            the matrix diagonal has non-unit elements
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DiagType.Unit">
            <summary>
            the matrix diagonal has unit elements
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.SideMode">
            <summary>
            The SideMode type indicates whether the dense matrix is on the left or right side
            in the matrix equation solved by a particular function. Its values correspond to Fortran
            characters ‘L’ or ‘l’ (left) and ‘R’ or ‘r’ (right) that are often used as parameters to
            legacy BLAS implementations.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.SideMode.Left">
            <summary>
            the matrix is on the left side in the equation
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.SideMode.Right">
            <summary>
            the matrix is on the right side in the equation
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.Operation">
            <summary>
            The Operation type indicates which operation needs to be performed with the
            dense matrix. Its values correspond to Fortran characters ‘N’ or ‘n’ (non-transpose), ‘T’
            or ‘t’ (transpose) and ‘C’ or ‘c’ (conjugate transpose) that are often used as parameters
            to legacy BLAS implementations
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Operation.NonTranspose">
            <summary>
            the non-transpose operation is selected
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Operation.Transpose">
            <summary>
            the transpose operation is selected
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Operation.ConjugateTranspose">
            <summary>
            the conjugate transpose operation is selected
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Operation.Hermitan">
            <summary>
            synonym of ConjugateTranspose
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Operation.Conjugate">
            <summary>
            the conjugate operation is selected
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.PointerMode">
            <summary>
            The PointerMode type indicates whether the scalar values are passed by
            reference on the host or device. It is important to point out that if several scalar values are
            present in the function call, all of them must conform to the same single pointer mode.
            The pointer mode can be set and retrieved using cublasSetPointerMode() and
            cublasGetPointerMode() routines, respectively.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.PointerMode.Host">
            <summary>
            the scalars are passed by reference on the host
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.PointerMode.Device">
            <summary>
            the scalars are passed by reference on the device
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.AtomicsMode">
            <summary>
            The type indicates whether cuBLAS routines which has an alternate implementation
            using atomics can be used. The atomics mode can be set and queried using and routines,
            respectively.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.AtomicsMode.NotAllowed">
            <summary>
            the usage of atomics is not allowed
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.AtomicsMode.Allowed">
            <summary>
            the usage of atomics is allowed
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.GemmAlgo">
            <summary>
            For different GEMM algorithm
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Default">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo0">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo1">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo2">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo3">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo4">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo5">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo6">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo7">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo8">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo9">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo10">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo11">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo12">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo13">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo14">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo15">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo16">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo17">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo18">
            <summary>
            sliced 32x32  
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo19">
            <summary>
            sliced 64x32
            </summary>  
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo20">
            <summary>
            sliced 128x32
            </summary>  
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo21">
            <summary>
            sliced 32x32  -splitK
            </summary>   
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo22">
            <summary>
            sliced 64x32  -splitK
            </summary>      
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo23">
            <summary>
            sliced 128x32 -splitK 
            </summary>    
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.DefaultTensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo0TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo1TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo2TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo3TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo4TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo5TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo6TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo7TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo8TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo9TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo10TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo11TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo12TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo13TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo14TensorOp">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.GemmAlgo.Algo15TensorOp">
            <summary>
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.Math">
            <summary>
            Enum for default math mode/tensor operation
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Math.DefaultMath">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Math.TensorOpMath">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Math.PedanticMath">
            <summary>
            same as using matching _PEDANTIC compute type when using cublas routine calls or cublasEx() calls with cudaDataType as compute type
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Math.TF32TensorOpMath">
            <summary>
            allow accelerating single precision routines using TF32 tensor cores
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.Math.DisallowReducedPrecisionReduction">
            <summary>
            flag to force any reductons to use the accumulator type and not output type in case of mixed precision routines with lower size output type
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.ComputeType">
            <summary>
            Enum for compute type<para/>
            - default types provide best available performance using all available hardware features
              and guarantee internal storage precision with at least the same precision and range;<para/>
            - _PEDANTIC types ensure standard arithmetic and exact specified internal storage format;<para/>
            - _FAST types allow for some loss of precision to enable higher throughput arithmetic.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute16F">
            <summary>
            half - default
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute16FPedantic">
            <summary>
            half - pedantic
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute32F">
            <summary>
            float - default
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute32FPedantic">
            <summary>
            float - pedantic
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute32FFast16F">
            <summary>
            float - fast, allows down-converting inputs to half or TF32
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute32FFast16BF">
            <summary>
            float - fast, allows down-converting inputs to bfloat16 or TF32
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute32FFastTF32">
            <summary>
            float - fast, allows down-converting inputs to TF32
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute64F">
            <summary>
            double - default
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute64FPedantic">
            <summary>
            double - pedantic
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute32I">
            <summary>
            signed 32-bit int - default
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.ComputeType.Compute32IPedantic">
            <summary>
            signed 32-bit int - pedantic
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.DataType">
            <summary>
            The cublasDataType_t type is an enumerant to specify the data precision. It is used
            when the data reference does not carry the type itself (e.g void *).
            To mimic the typedef in cublas_api.h, we redefine the enum identically to cudaDataType
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_R_16F">
            <summary>
            16 bit real 
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_C_16F">
            <summary>
            16 bit complex
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_R_32F">
            <summary>
            32 bit real
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_C_32F">
            <summary>
            32 bit complex
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_R_64F">
            <summary>
            64 bit real
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_C_64F">
            <summary>
            64 bit complex
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_R_8I">
            <summary>
            8 bit real as a signed integer 
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_C_8I">
            <summary>
            8 bit complex as a pair of signed integers
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_R_8U">
            <summary>
            8 bit real as a signed integer 
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.DataType.CUDA_C_8U">
            <summary>
            8 bit complex as a pair of signed integers
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.CudaBlasHandle">
            <summary>
            Opaque structure holding CUBLAS library context
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaBlas.CudaBlasHandle.Pointer">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaBlas.cublasLogCallback">
            <summary>
            Cublas logging
            </summary>
        </member>
    </members>
</doc>
